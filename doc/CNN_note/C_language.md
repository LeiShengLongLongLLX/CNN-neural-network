# C language

# 一、数据类型 (Data type)

C 语言是一门**强类型、贴近硬件的语言**

数据类型的本质是：**告诉编译器一段内存有多大、如何解释这段内存**

---

## 1.1 基本类型

### 1.1.1 char / short / int / long

| 类型    | 最小位宽（标准） | 常见位宽（32 位系统） |
| ----- | -------- | ------------ |
| char  | ≥ 8 bit  | 8 bit（1 字节）  |
| short | ≥ 16 bit | 16 bit（2 字节） |
| int   | ≥ short  | 32 bit（4 字节） |
| long  | ≥ int    | 32 或 64 bit  |

**注意**

* C 标准只规定**大小关系**，不规定具体字节数
* 实际大小**与平台、编译器有关**
* 嵌入式 / RISC-V / FPGA SoC 中尤为重要

```c
printf("char : %zu\n", sizeof(char));
printf("int  : %zu\n", sizeof(int));
```

---

### 1.1.2 signed / unsigned

#### （1）含义

* `signed`：有符号数（可表示正负）
* `unsigned`：无符号数（只表示非负）

```c
signed int a = -10;
unsigned int b = 10;
```

#### （2）取值范围差异（以 32 位 int 为例）

| 类型           | 范围           |
| ------------ | ------------ |
| signed int   | -2³¹ ~ 2³¹-1 |
| unsigned int | 0 ~ 2³²-1    |

**隐含规则**

* **整型默认是 signed**
* `char` 是否有符号由**编译器决定**（非常重要）

```c
char c = -1;   // 可能是 -1，也可能是 255
```

> **建议：明确写 signed / unsigned**

---

## 1.2 浮点类型

### 1.2.1 float / double

| 类型     | 常见大小 | 精度          |
| ------ | ---- | ----------- |
| float  | 4 字节 | ~6~7 位十进制   |
| double | 8 字节 | ~15~16 位十进制 |

```c
float  f = 3.14f;
double d = 3.14;
```

**注意**

* 浮点数在内存中不是精确值（IEEE 754）
* **不要直接用 `==` 比较浮点数**

```c
if (fabs(a - b) < 1e-6) { ... }
```

**嵌入式补充**

* 很多 MCU / 软核 **没有硬件浮点**
* 浮点运算 = 慢 + 代码大

---

## 1.3 派生类型

派生类型：**从基本类型“派生”出来的类型**

---

### 1.3.1 指针（pointer）

#### （1）定义

```c
int a = 10;
int *p = &a;
```

* `p` 保存的是 **a 的地址**
* `*p` 表示 **访问地址对应的值**

**核心公式**

> 指针 = 地址 + 类型

#### （2）指针大小

* **所有指针大小相同**
* 32 位系统：4 字节
* 64 位系统：8 字节

```c
sizeof(int*) == sizeof(char*)
```

---

### 1.3.2 数组（array）

```c
int arr[5] = {1,2,3,4,5};
```

* 数组是一段**连续的内存**
* `arr[i]` 等价于 `*(arr + i)`

**数组名的本质**

* 大多数情况下，数组名会退化为指向首元素的指针
* 但：

```c
sizeof(arr) != sizeof(&arr)
```

---

## 1.4 构造类型

### 1.4.1 struct（结构体）

结构体用于**组合不同类型的数据**

```c
struct Student {
    int id;
    char name[20];
};
```

* 成员按声明顺序存放
* 可能存在 **内存对齐**

```c
struct Student s;
```

---

### 1.4.2 union（共用体）

```c
union Data {
    int i;
    float f;
};
```

* 所有成员 **共用同一块内存**
* 大小 = 最大成员大小

📌 **特点**

* 同一时刻只能“正确使用”一个成员
* 常用于：

  * 协议解析
  * 寄存器映射

---

## 1.5 void 类型

### 1.5.1 void 的三种常见用法

#### （1）函数无返回值

```c
void func(void);
```

#### （2）通用指针

```c
void *p;
```

* `void*` 可以指向任何类型
* **不能直接解引用**

```c
int a = 10;
void *p = &a;
printf("%d", *(int*)p);
```

#### （3）函数参数为空

```c
int func(void);
```

---

## 1.6 sizeof 的本质（和平台有关）

### 1.6.1 sizeof 是什么

* **编译期运算符**
* 返回类型或对象所占的**字节数**

```c
sizeof(int)
sizeof(a)
```

> 注： **不是函数**

---

### 1.6.2 sizeof 与平台

| 平台   | 指针 | int | long |
| ---- | -- | --- | ---- |
| 32 位 | 4  | 4   | 4    |
| 64 位 | 8  | 4   | 8    |

#### **常见坑**

```c
int arr[10];
sizeof(arr);     // 40
sizeof(arr + 0); // 8（指针）
```

---

## 1.7 总结

> **C 语言的数据类型，本质是在“描述内存”和“如何解释内存”**

---

## 二、变量
### 2.1 变量的定义与声明
### 2.2 变量的作用域
  - 局部变量
  - 全局变量
### 2.3 生命周期
### 2.4 static 变量
### 2.5 extern 变量
### 2.6 volatile

---

# 二、变量 (Varible)

变量的本质是：

> **在内存中开辟一块空间，并给这块空间起一个名字**

理解变量，必须同时理解：

* **作用域（能在哪用）**
* **生命周期（什么时候存在）**
* **存储位置（在哪块内存）**

---

## 2.1 变量的定义与声明

### 2.1.1 变量定义（Definition）

**定义 = 分配内存**

```c
int a;
```

* 编译器为 `a` 分配内存空间
* 变量真正“存在”了

---

### 2.1.2 变量声明（Declaration）

**声明 = 告诉编译器变量存在，但不分配内存**

```c
extern int a;
```

### 2.1.3 核心区别

| 项目     | 定义 | 声明 |
| ------ | -- | -- |
| 是否分配内存 | ✅  | ❌  |
| 是否可多次  | ❌  | ✅  |

> **注意：**
> 
> * 普通 `int a;` 既是声明也是定义
> * `extern` 才是纯声明

---

## 2.2 变量的作用域（Scope）

作用域决定：

> **变量在代码中“能被访问的范围”**

---

### 2.2.1 局部变量

```c
void func(void)
{
    int x = 10;
}
```

* 定义在函数内部或代码块中
* 只能在所在代码块中使用

#### **特点**

* 存在于栈中
* 不初始化时是**随机值**

---

### 2.2.2 全局变量

```c
int g_val = 100;

void func(void)
{
    printf("%d", g_val);
}
```

* 定义在函数外
* 整个工程可见（需配合 `extern`）

#### **特点**

* 存放在 **全局区（.data / .bss）**
* 生命周期贯穿整个程序

---

## 2.3 生命周期（Lifetime）

生命周期描述的是：

> **变量从“创建”到“销毁”的时间**

---

### 2.3.1 局部变量生命周期

```c
void func(void)
{
    int a = 10;
}   // a 在这里被销毁
```

* 进入函数：创建
* 离开函数：销毁

> 注：**栈变量**

---

### 2.3.2 全局变量生命周期

```c
int g = 0;
```

* 程序开始 → 程序结束
* 始终存在

> 注：**与 main 是否执行无关**

---

## 2.4 static 变量（静态变量）

`static` 是 C 语言中**极其重要、极易混淆**的关键字。

---

### 2.4.1 static 修饰局部变量

```c
void func(void)
{
    static int cnt = 0;
    cnt++;
}
```

📌 **特点**

* 只初始化一次
* 生命周期 = 整个程序
* 作用域 = 该函数内部

#### **典型用途**

* 函数内部计数器
* 状态保持

---

### 2.4.2 static 修饰全局变量

```c
static int g_val = 10;
```

#### **特点**

* 作用域限制在当前 `.c` 文件
* 防止全局变量“污染”其他文件

#### **工程级最佳实践**

> 能 static 就 static

---

### 2.4.3 static 修饰函数

```c
static void helper(void)
{
}
```

* 函数仅在本文件可见
* 不会被其他文件链接

---

## 2.5 extern 变量

`extern` 用于：

> **在一个文件中使用另一个文件定义的变量**

---

### 2.5.1 使用方法

**a.c**

```c
int g_data = 100;
```

**b.c**

```c
extern int g_data;
```

---

### 2.5.2 extern 的本质

* 只是**声明**
* 不分配内存
* 由链接器解决符号

#### **常见错误**

```c
extern int x = 10;  // ❌ 这是定义，不是声明
```

---

## 2.6 volatile（嵌入式重点）

`volatile` 告诉编译器：

> **这个变量的值可能随时被“不可预知地改变”**

---

### 2.6.1 为什么需要 volatile

```c
while (flag == 0) {
}
```

如果 `flag` 没有 `volatile`：

* 编译器可能优化成死循环

---

### 2.6.2 volatile 的典型使用场景

1. **硬件寄存器**

```c
#define GPIO (*(volatile unsigned int*)0x40000000)
```

2. **中断共享变量**

```c
volatile int irq_flag;
```

3. **多线程 / 多核通信**

---

### 2.6.3 volatile 的限制

`volatile` **不能保证**

* 原子性
* 线程安全

只保证：

* **每次都从内存读写**

---

## 2.7 总结

| 关键字      | 作用         |
| -------- | ---------- |
| auto     | 默认局部变量     |
| static   | 改变生命周期或可见性 |
| extern   | 跨文件访问变量    |
| volatile | 禁止编译器优化    |

> **变量 = 名字 + 内存 + 作用域 + 生命周期**

---

# 三、函数 (Function)

函数的本质是：

> **一段可复用的代码 + 独立的栈帧 + 明确的输入输出**

理解函数，关键不在“会不会写”，而在：

* 参数是怎么传的
* 返回值从哪来
* 调用时内存发生了什么

---

## 3.1 函数定义与声明

### 3.1.1 函数定义（Definition）

```c
int add(int a, int b)
{
    return a + b;
}
```

函数定义包含：

* 返回类型
* 函数名
* 参数列表
* 函数体

> 注：**函数定义只能有一次**

---

### 3.1.2 函数声明（Declaration）

```c
int add(int a, int b);
```

作用：

* 告诉编译器函数的接口
* 不生成函数实体

> **声明可以多次**
> 
> 常放在 `.h` 文件中

---

### 3.1.3 函数声明与定义的关系

```c
int add(int a, int b);  // 声明

int main(void)
{
    add(1, 2);
}

int add(int a, int b)  // 定义
{
    return a + b;
}
```

---

## 3.2 参数传递

重要结论先给出

> **C 语言只有值传递，没有引用传递**

所谓“指针传递”，本质仍然是值传递。

---

### 3.2.1 值传递

```c
void func(int x)
{
    x = 100;
}

int main(void)
{
    int a = 10;
    func(a);
}
```

* `x` 是 `a` 的拷贝
* 修改 `x` 不影响 `a`

> 本质： **参数在栈上重新开辟空间**

---

### 3.2.2 指针传递（本质仍是值传递）

```c
void func(int *p)
{
    *p = 100;
}

int main(void)
{
    int a = 10;
    func(&a);
}
```

* 传的是 **地址的值**
* 通过地址修改了原变量

**记住这句话**

> 指针传递 = 地址的值传递

---

## 3.3 返回值

### 3.3.1 基本返回值

```c
int add(int a, int b)
{
    return a + b;
}
```

* 返回值通过寄存器传递（如 RISC-V：`a0`）
* `return` 会触发函数返回

---

### 3.3.2 返回指针（常见陷阱）

错误示例：

```c
int* func(void)
{
    int a = 10;
    return &a;  // ❌ 返回局部变量地址
}
```

原因：

* `a` 在栈上
* 函数返回后栈帧被销毁

---

### 3.3.3 正确返回方式

```c
static int a = 10;
return &a;
```

或

```c
int *p = malloc(sizeof(int));
return p;
```

---

## 3.4 栈帧（函数调用发生了什么）

这是**理解函数的关键部分**。

---

### 3.4.1 什么是栈帧（Stack Frame）

栈帧包含：

* 返回地址
* 参数
* 局部变量
* 保存的寄存器

**每调用一次函数，就创建一个栈帧**

---

### 3.4.2 函数调用流程（简化）

```text
caller:
  ↓ 压参数
  ↓ 保存返回地址
  ↓ 跳转到被调函数

callee:
  ↓ 创建栈帧
  ↓ 执行函数体
  ↓ 销毁栈帧
  ↓ 返回
```

> 递归本质 = 多个栈帧叠加

---

### 3.4.3 栈溢出

* 递归太深
* 局部数组太大

嵌入式中尤其危险

---

## 3.5 inline

`inline` 用于：

> **建议编译器将函数调用展开成代码**

---

### 3.5.1 使用方式

```c
inline int add(int a, int b)
{
    return a + b;
}
```

**注意**

* `inline` 是建议，不是强制
* 可能被编译器忽略

---

### 3.5.2 inline 的优缺点

#### 优点：

* 减少函数调用开销

#### 缺点：

* 增加代码体积
* 不利于调试

#### **嵌入式建议**

* 小函数
* 高频调用
* 放在 `.h`

---

## 3.6 递归

递归 = 函数调用自身。

---

### 3.6.1 递归三要素

1. 递归调用
2. 终止条件
3. 问题规模缩小

```c
int factorial(int n)
{
    if (n == 0)
        return 1;
    return n * factorial(n - 1);
}
```

---

### 3.6.2 递归的风险

* 占用大量栈空间
* 易导致栈溢出

> **嵌入式中慎用递归**

---

## 3.7 总结

| 项目     | 要点     |
| ------ | ------ |
| 参数传递   | 只有值传递  |
| 栈帧     | 每次调用独立 |
| 返回值    | 不返回栈地址 |
| inline | 建议，不保证 |
| 递归     | 本质是栈   |

> **函数调用 = 压栈 → 执行 → 出栈**

---

# 四、数组 (Array)

数组的本质一句话先给出：

> **数组 = 一段“连续、同类型、固定大小”的内存空间**

理解数组，关键不是下标，而是：

* 内存连续性
* 与指针的关系
* 在函数中的“退化行为”

---

## 4.1 一维数组

### 4.1.1 定义与初始化

```c
int arr[5];                  // 未初始化
int arr2[5] = {1,2,3,4,5};   // 完全初始化
int arr3[5] = {1,2};         // 部分初始化
```

**规则**

* 未显式初始化 → 值不确定（局部数组）
* 全局数组 / static 数组 → 默认初始化为 0

---

### 4.1.2 访问方式

```c
arr[i] == *(arr + i)
```

> **数组访问本质是指针运算**

---

### 4.1.3 数组类型

> 数组的类型 = 元素类型 + 元素个数

```ini
ArrayType = ElementType × Length
```

---

## 4.2 多维数组

### 4.2.1 定义

```c
int a[2][3] = {
    {1,2,3},
    {4,5,6}
};
```

* 本质是：**数组的数组**
* 每一行是一个一维数组

---

### 4.2.2 多维数组的存储顺序

C 语言使用 **行优先（Row-major）** 存储：

```text
a[0][0] a[0][1] a[0][2] a[1][0] a[1][1] a[1][2]
```

内存仍然是 **连续的一块**

---

### 4.2.3 多维数组的指针类型（容易错）

```c
int (*p)[3] = a;
```

* `p` 是 **指向“长度为 3 的 int 数组”的指针**
* 不是 `int**`

---

## 4.3 数组在内存中的布局

### 4.3.1 连续性

```c
int arr[4];
```

内存布局：

```
| arr[0] | arr[1] | arr[2] | arr[3] |
```

元素之间 **无空隙**

---

### 4.3.2 地址关系

```c
&arr[0] == arr
&arr[i] == arr + i
```

步长由 **元素类型决定**

---

### 4.3.3 数组与内存区域

| 数组类型          | 存储位置         |
| ------------- | ------------ |
| 局部数组          | 栈            |
| static / 全局数组 | .data / .bss |

---

## 4.4 数组名的本质

这是**本章最重要的一节**。

---

### 4.4.1 数组名 ≠ 普通变量

```c
int arr[10];
```

#### 数组名的三个特点：

1. 代表 **首元素地址**
2. **不能被赋值**
3. **不是左值**

```c
arr = other;   // ❌
```

---

### 4.4.2 数组名何时“退化”为指针？

在以下场景中：

* 作为函数参数
* 表达式中使用（非 sizeof / &）

```c
sizeof(arr);    // 数组总大小
sizeof(arr+0);  // 指针大小
```

---

### 4.4.3 &arr 的特殊性（进阶）

```c
&arr      // 类型：int (*)[10]
arr       // 类型：int*
```

步长不同：

* `arr + 1` → 移动一个元素
* `&arr + 1` → 跳过整个数组

---

## 4.5 数组作为函数参数

### 4.5.1 一维数组作为参数

```c
void func(int arr[])
```

等价于：

```c
void func(int *arr)
```

**数组作为参数会退化为指针**

---

### 4.5.2 sizeof 的陷阱

```c
void func(int arr[])
{
    sizeof(arr);  // ❌ 得到的是指针大小
}
```

**函数中无法获取数组真实长度**

---

### 4.5.3 正确传递数组长度

```c
void func(int *arr, int len)
{
}
```

---

### 4.5.4 多维数组作为参数（重点）

```c
void func(int arr[][3])
```

或

```c
void func(int (*arr)[3])
```

**除第一维外，其余维度必须明确**

---

## 4.6 总结

1. 数组名不是指针，但会退化
2. `sizeof(arr)` 和 `sizeof(arr[])` 结果不同
3. 多维数组 ≠ 二级指针
4. 数组越界是未定义行为

> **数组是“连续内存”，指针是“访问方式”**

---

# 五、指针 (Pin)

一句话先给出指针的本质：

> **指针 = 存储“地址”的变量 + 明确的类型**

理解指针，关键在两点：

1. 指针里存的是什么
2. 编译器如何用“指针类型”解释这块地址

---

## 5.1 指针的基本概念

### 5.1.1 什么是指针

```c
int a = 10;
int *p = &a;
```

* `a`：普通变量，存的是值
* `p`：指针变量，存的是 **a 的地址**
* `*p`：对地址解引用，访问地址里的内容

#### **三件事一定要分清**

* `a`：值
* `&a`：地址
* `*p`：地址对应的值

---

### 5.1.2 指针的类型

```c
int    *p1;
char   *p2;
double *p3;
```

**指针类型的意义**

* 决定：

  * 解引用时读多少字节
  * 指针加减的步长

> **指针类型 ≠ 地址大小**

---

## 5.2 指针与变量

### 5.2.1 指针指向变量

```c
int a = 10;
int *p = &a;
```

* `p` 指向 `a`
* 通过 `p` 可修改 `a`

```c
*p = 20;
```

---

### 5.2.2 指针作为变量本身

```c
int *p;
```

* `p` 本身也是变量
* 占用内存（4 / 8 字节）

**未初始化的指针是野指针**

---

## 5.3 指针与数组

这是**指针最重要、最容易混的关系**。

---

### 5.3.1 数组名与指针

```c
int arr[5];
int *p = arr;
```

说明：

* `arr` 退化为 `&arr[0]`
* `p` 指向数组首元素

---

### 5.3.2 指针访问数组

```c
p[i] == *(p + i)
```

**数组下标本质是指针运算**

---

### 5.3.3 指针 vs 数组（本质区别）

| 项目      | 数组    | 指针    |
| ------- | ----- | ----- |
| 是否可重新指向 | ❌     | ✅     |
| sizeof  | 整个数组  | 指针大小  |
| 内存分配    | 编译期固定 | 运行期可变 |

---

### 5.3.4 指向数组的指针（进阶）

```c
int (*p)[5];
```

* `p` 指向 **整个数组**
* 步长 = `sizeof(int[5])`

---

## 5.4 指针与函数

---

### 5.4.1 指针作为函数参数

```c
void func(int *p)
{
    *p = 100;
}
```

常用于：

* 修改实参
* 传递大对象
* 返回多个结果

---

### 5.4.2 函数返回指针

❌ 错误：

```c
int* func(void)
{
    int a = 10;
    return &a;
}
```

#### 为什么错？

`x` 是**栈变量**

函数返回后：栈帧销毁, `x`的内存无效, 返回的是悬空指针

返回栈变量地址 → 悬空指针

---

### 5.4.3 函数指针

```c
int add(int a, int b);
int (*fp)(int, int) = add;
```

用途：

* 回调函数
* 状态机
* 驱动接口

---

## 5.5 指针与结构体

### 5.5.1 结构体指针

```c
struct Student {
    int id;
};

struct Student s;
struct Student *p = &s;
```

---

### 5.5.2 `->` 运算符

```c
p->id == (*p).id
```

📌 **语法糖**

---

### 5.5.3 嵌入式中的典型用法

```c
#define UART0 ((volatile struct uart_reg *)0x40000000)
```

> **寄存器映射**

---

## 5.6 二级指针

### 5.6.1 定义

```c
int **pp;
```

* `pp` → 指向一个指针
* 常见于：

  * 修改指针本身
  * 动态二维数组
  * 参数输出

---

### 5.6.2 示例：修改指针

```c
void alloc(int **p)
{
    *p = malloc(sizeof(int));
}
```

---

## 5.7 野指针 / 悬空指针

### 5.7.1 野指针

```c
int *p;
```

* 未初始化
* 指向未知地址

---

### 5.7.2 悬空指针

```c
int *p = malloc(sizeof(int));
free(p);
// p 仍然指向已释放内存
```

---

### 5.7.3 预防方法

```c
p = NULL;
```

访问 NULL 可快速暴露错误

---

## 5.8 总结

1. 指针必须初始化
2. 不要返回栈地址
3. 指针类型必须匹配
4. 数组 ≠ 指针
5. 注意指针运算步长

> **指针不是“难”，而是“对内存的精确控制”**

---

# 六、结构体 (Struct)

---

## 6.1 结构体定义

### 1️⃣ 什么是结构体？

> **结构体是一种用户自定义类型，用来把“不同类型的数据”组合成一个整体。**

和数组的区别：

* 数组：同一类型
* 结构体：**不同类型**

---

### 2️⃣ 基本定义方式

```c
struct Person {
    int age;
    char gender;
    float height;
};
```

#### 说明：

* `struct Person` 是一种 **类型**
* 花括号里的是 **成员（member）**

---

### 3️⃣ 只定义结构体，不定义变量

```c
struct Student {
    int id;
    char name[20];
};
```

---

### 4️⃣ 定义结构体的同时定义变量

```c
struct Student {
    int id;
    char name[20];
} s1, s2;
```

---

## 6.2 结构体变量

### 1️⃣ 定义结构体变量

```c
struct Student s;
```

---

### 2️⃣ 成员访问（点运算符）

```c
s.id = 1001;
```

---

### 3️⃣ 初始化

```c
struct Student s = {1001, "Tom"};
```

或（推荐）：

```c
struct Student s = {
    .id = 1001,
    .name = "Tom"
};
```

**指定成员初始化**（工程强烈推荐）

---

## 6.3 结构体指针

### 1️⃣ 定义结构体指针

```c
struct Student *p;
```

---

### 2️⃣ 使用 `->` 访问成员

```c
p->id = 1001;
```

等价于：

```c
(*p).id = 1001;
```

📌 **`->` 本质是语法糖**

---

### 3️⃣ 结构体作为函数参数（推荐指针）

```c
void print_student(struct Student *s)
{
    printf("%d\n", s->id);
}
```

📌 避免大对象拷贝，提高效率

---

## 6.4 结构体内存对齐（重点）

### 1️⃣ 为什么要内存对齐？

> 为了提高 CPU 访问效率
> 某些架构 **不对齐访问会直接异常（嵌入式非常常见）**

---

### 2️⃣ 对齐规则（必背）

1. 成员按声明顺序排列
2. 每个成员起始地址是：

   ```
   min(成员大小, 对齐单位) 的整数倍
   ```
3. 结构体总大小是 **最大对齐值的整数倍**

---

### 3️⃣ 示例（非常重要）

```c
struct A {
    char a;   // 1
    int  b;   // 4
    char c;   // 1
};
```

内存布局：

```text
偏移
0   a
1   padding
2   padding
3   padding
4   b
5   b
6   b
7   b
8   c
9   padding
10  padding
11  padding
```

```c
sizeof(struct A) == 12
```

---

### 4️⃣ 控制对齐（嵌入式常用）

```c
#pragma pack(1)
struct B {
    char a;
    int b;
};
#pragma pack()
```

⚠️ **慎用，可能影响性能**

---

## 6.5 typedef struct

### 1️⃣ 为什么要用 typedef？

```c
struct Student s;
```

太长，不利于工程维护。

---

### 2️⃣ 常见写法（推荐）

```c
typedef struct {
    int id;
    char name[20];
} Student;
```

使用：

```c
Student s;
Student *p;
```

📌 **这是嵌入式/驱动代码的标配写法**

---

### 3️⃣ 另一种写法（保留 tag）

```c
typedef struct Student {
    int id;
} Student;
```

---

## 6.6 结构体在嵌入式中的应用

### 6.6.1 寄存器映射（核心重点）

> **用结构体“描述硬件寄存器布局”**

---

### 示例：GPIO 寄存器映射

```c
typedef struct {
    volatile uint32_t MODER;
    volatile uint32_t OTYPER;
    volatile uint32_t OSPEEDR;
    volatile uint32_t PUPDR;
    volatile uint32_t IDR;
    volatile uint32_t ODR;
} GPIO_TypeDef;
```

---

### 寄存器基地址

```c
#define GPIOA_BASE 0x40020000
```

---

### 映射成结构体指针

```c
#define GPIOA ((GPIO_TypeDef *)GPIOA_BASE)
```

---

### 使用方式（非常优雅）

```c
GPIOA->MODER = 0x55555555;
```

### **本质：**

* 把硬件地址当成结构体
* 通过指针访问成员
* 编译器自动帮你算偏移

---

### 6.6.2 为什么成员要 volatile？

```c
volatile uint32_t ODR;
```

防止编译器优化：

* 硬件寄存器可能“随时变”
* 每次访问都必须真实读写

---

## 6.7 总结

> * 结构体是异构数据的组合
> * 指针 + 结构体是工程核心
> * 内存对齐直接影响性能和正确性
> * 寄存器映射是嵌入式 C 的灵魂

---

好，这一节正好把 **C 语言里“看起来简单，但工程里很有分量”的两种类型：`enum` 和 `union`** 系统性地补齐。
我按 **定义 → 本质 → 用法 → 易错点 → 嵌入式/工程应用** 给你一份**可直接进你笔记本的总结**。

---

# 七、枚举 (enum)

## 7.1 enum 的定义

```c
enum Color {
    RED,
    GREEN,
    BLUE
};
```

* `RED = 0`
* `GREEN = 1`
* `BLUE = 2`

>  默认从 **0 开始，依次 +1**

---

## 7.2 enum 的本质（非常重要）

> **enum 本质上是一个“整型常量集合”**

* 底层类型：**int（或能容纳的最小整型，编译器决定）**
* **不是真正的新类型**
* 编译后：没有 enum 这个概念，只有整数

```c
enum Color c = RED;
```

等价于：

```c
int c = 0;
```

---

## 7.3 显式赋值

```c
enum State {
    IDLE = 0,
    RUN  = 3,
    STOP = 10
};
```

后面的成员如果没指定：

```c
STOP = 10
NEXT = 11
```

---

## 7.4 enum 的作用（为什么要用）

### 1️⃣ 提高可读性

```c
if (state == RUN)   // 好
if (state == 3)     // 差
```

---

### 2️⃣ 代替宏常量（更安全）

```c
#define RUN 3        // 无类型
enum { RUN = 3 };   // 有作用域
```

---

## 7.5 enum 与 switch（经典组合）

```c
switch (state) {
case IDLE:
    break;
case RUN:
    break;
}
```

> **状态机核心写法**

---

## 7.6 typedef enum（工程中最常见）

```c
typedef enum {
    IDLE,
    RUN,
    STOP
} state_t;

state_t s;
```

✔️ **这是工业级写法**

---

### 1.7 enum 的常见误区

> enum 会限制取值范围？
> 
> **不会**

```c
state_t s = 100;   // 编译器通常不报错
```

- enum 占 1 字节？

- **通常占 int 大小**

---

# 八、共用体 (union)

---

## 8.1 union 的定义

```c
union Data {
    int   i;
    float f;
    char  c[4];
};
```

---

## 8.2 union 的核心本质（必须牢记）

> **所有成员共享同一块内存**

* 大小 = **最大成员的大小**
* 同一时间，只能“逻辑上”使用一个成员

```c
union Data d;
```

内存示意：

```text
| 4 bytes |
```

---

## 8.3 union 的内存大小

```c
sizeof(union Data) == max(sizeof(int), sizeof(float), sizeof(char[4]))
```

对齐后可能更大

---

## 8.4 union 的读写行为（重点）

```c
union Data d;
d.i = 0x3f800000;
printf("%f", d.f);
```

 **按位重解释（type punning）**

---

## 8.5 union 的典型用途

#### 1️⃣ 不同数据格式的“视角切换”

```c
union {
    uint32_t val;
    uint8_t  byte[4];
} u;
```

用途：

* 大小端分析
* 通信协议解析

---

#### 2️⃣ 节省内存（嵌入式）

```c
union {
    int  temp;
    char buf[64];
} u;
```

📌 同一时刻只用一种数据

---

## 8.6 union + struct（工程经典）

```c
typedef union {
    uint32_t value;
    struct {
        uint32_t EN  : 1;
        uint32_t MODE: 2;
        uint32_t RES : 29;
    } bit;
} REG_t;
```

**寄存器映射神器**

---

## 8.7 union 的危险点

写的是 `i`，却读 `f`

```c
d.i = 10;
printf("%f", d.f);  // 未定义/依赖实现
```

除非你明确是“按位解释”

---

## 8.8 enum + union 的经典组合（状态数据）

```c
typedef enum {
    TYPE_INT,
    TYPE_FLOAT
} type_t;

typedef struct {
    type_t type;
    union {
        int   i;
        float f;
    } data;
} value_t;
```

使用：

```c
value_t v;
v.type = TYPE_INT;
v.data.i = 10;
```

 **C 语言实现“变体类型”的标准方式**

---

## 8.9 enum vs union vs struct 对比总结

| 类型     | 核心作用             |
| ------ | ---------------- |
| enum   | **整数语义化（状态/模式）** |
| struct | **同时存在的成员**      |
| union  | **互斥存在的成员（省内存）** |

---

# 九、内存与编译 (Memory & Complie)

---

## 9.1 栈 / 堆 / 全局区 / 代码区 （四区）

### 9.1.1 程序运行时的内存整体布局（逻辑视角）

典型进程内存模型（从低地址到高地址）：

```text
.text      （代码段）
.rodata    （只读数据）
.data      （已初始化全局变量）
.bss       （未初始化全局变量）
heap       （堆，向上增长）
↓
↑
stack      （栈，向下增长）
```

注：上图描述的是“典型进程的虚拟地址的空间布局”

具体情况是操作系统、编译器、链接脚本的共同决定结果

---

### 9.1.2 栈（Stack）

#### 特点：

* 自动分配、自动释放
* 每次函数调用都会创建 **栈帧**
* 速度快，空间有限

#### 存放内容：

* 局部变量
* 函数参数
* 返回地址
* 保存的寄存器

```c
void func(void)
{
    int a = 10;   // 栈上
}
```

⚠️ 问题：

* 栈溢出（递归过深、大数组）

---

### 9.1.3 堆（Heap）

特点：

* 手动申请 / 手动释放
* 生命周期由程序员控制
* 空间大但速度慢

```c
int *p = malloc(sizeof(int));  // 堆
```

⚠️ 常见问题：

* 内存泄漏
* 野指针
* 碎片化（嵌入式尤为严重）

---

### 9.1.4 全局区（静态区）

存放：

* 全局变量
* static 变量（静态变量）
* 具有静态存储期的常量
  - 全局 const
  - static const

* 常见段
  - `.data`，
  - `.bss`，
  - `.rodata`

```c
int g = 10;          // .data
static int s;        // .bss
```

特点：

* 程序启动时分配
* 程序结束时释放

### 9.1.5 代码区

存放：

* 程序的可执行指令 **（二进制代码）**
  - 各函数的机器指令
  - 启动代码
  - 编译器生成的辅助代码

> 本质：CPU实际取指运行的地方

* 常见段：
  - `.text`
  - `.init`
  - `.vectors`

特点
* 只读
* 共享
* 可执行，在整个程序生命周期一直存在

---

## 9.2 malloc / free原理

### 9.2.1 malloc 是干嘛的？

```c
void *malloc(size_t size);
```

> 向 **堆** 申请一块连续内存

---

### 9.2.2 malloc 的本质

> malloc 本身不是系统调用
> 
> 它是 **C 库对底层内存管理的封装**

底层可能使用：

* `brk / sbrk`
* `mmap`
* 或嵌入式里的 **静态内存池**

---

### 9.2.3 malloc 内部做了什么？

简化流程：

```text
1. 查找空闲内存块
2. 若足够大 → 切割
3. 标记为已占用
4. 返回指针
```

---

### 9.2.4 free 的本质

```c
free(p);
```

只是把内存标记为“可复用”, 并不一定立刻归还给 OS

---

### 9.2.5 嵌入式里的现实问题

⚠️ 很多嵌入式项目：

* 禁用 malloc/free
* 使用静态内存池

原因：

* 内存碎片
* 不可预测性

---

## 9.3 .text / .data / .bss（编译 & 链接视角）

这是 **编译器 + 链接器眼里的程序**

---

### 9.3.1 .text 段（代码段）

存放：

* 机器指令
* 通常只读

```c
int add(int a, int b)
{
    return a + b;
}
```

👉 在 `.text`

---

### 9.3.2 .data 段（已初始化全局数据）

特点：

* 有初始值
* 占用 Flash + RAM

```c
int g = 10;
static int s = 5;
```

---

### 9.3.3 .bss 段（未初始化全局数据）

特点：

* 初始值默认为 0
* **不占 Flash**
* 启动时清零

```c
int g;
static int s;
```

---

### 9.3.4 .rodata（只读数据）

存放：

* 字符串常量
* const 全局变量

```c
const char *s = "hello";
```

---

### 9.3.5 一个非常重要的对比

| 段       | 占 Flash | 占 RAM |
| ------- | ------- | ----- |
| .text   | ✅       | ❌     |
| .rodata | ✅       | ❌     |
| .data   | ✅       | ✅     |
| .bss    | ❌       | ✅     |

---

## 9.4 ELF 文件结构（程序文件本体）

### 9.4.1 什么是 ELF？

> **ELF（Executable and Linkable Format）**
> 是 Linux / 嵌入式下最常见的可执行文件格式

---

### 9.4.2 ELF 的主要组成

```text
ELF Header
Program Header Table
Section Header Table
Sections（.text .data .bss …）
```

---

### 9.4.3 Section vs Segment（重点）

| 概念      | 用途    |
| ------- | ----- |
| Section | 给链接器用 |
| Segment | 给加载器用 |

Section 会被“打包”成 Segment

---

### 9.4.4 常见 section

| Section | 作用     |
| ------- | ------ |
| .text   | 代码     |
| .data   | 已初始化数据 |
| .bss    | 未初始化数据 |
| .rodata | 常量     |
| .symtab | 符号表    |
| .strtab | 字符串表   |

---

### 9.4.5 工程实践

```bash
readelf -h a.out
readelf -S a.out
objdump -h a.out
```

---

## 9.5 一个“全链路”理解（非常重要）

```text
.c
 ↓ 编译
.o        （section 级）
 ↓ 链接
ELF       （section + segment）
 ↓ 加载
内存布局（text / data / bss / heap / stack）
```

---

## 9.6 总结

* 栈用于函数调用，堆用于动态分配
* 全局变量位于 data / bss
* .text / .data / .bss 是编译链接视角
* 栈 / 堆 是运行时视角
* ELF 是程序在磁盘上的最终形态

---

## 八、常见的问题与坑

---

# 十、数据类型进阶版 (typedef优化后的)

## 10.1 这些类型是什么？

像下面这些：

```c
uint8_t   uint16_t   uint32_t   uint64_t
int8_t    int16_t    int32_t    int64_t
```

它们不是 C 语言“原生关键字”，而是：

> **通过 typedef 定义的、具有“确定字长”的整数类型**

---

## 10.2  它们从哪里来？

### 1️⃣ 定义在标准头文件中

```c
#include <stdint.h>
```

这是 **C99 标准**引入的头文件。

---

### 2️⃣ 本质是 typedef

在 `<stdint.h>` 里（简化理解）：

```c
typedef unsigned int  uint32_t;
typedef signed int    int32_t;
```

实际映射取决于平台，但标准保证：

> `uint32_t` **一定是 32 位无符号整数**

---

## 10.3 为什么 C 标准要“人为定义”这些类型？

### 1️⃣ 因为 C 的基础类型大小不固定

| 类型    | 大小是否固定  |
| ----- | ------- |
| char  | ≥ 1 字节  |
| short | ≥ char  |
| int   | ≥ short |
| long  | ≥ int   |

**没有任何一条保证 int = 32 位**

---

### 2️⃣ 但工程世界需要“绝对确定”

* 寄存器：32 bit
* 协议字段：16 bit
* 文件格式：8 / 32 bit
* 网络包：bit 级对齐

👉 **不能靠 int 碰运气**

---

## 10.4 标准整数类型的分类（非常重要）

### 1 精确宽度类型（Exact-width）

> **如果平台支持，才定义**

```c
uint8_t   int8_t
uint16_t  int16_t
uint32_t  int32_t
uint64_t  int64_t
```

#### 特点：

* 精确位宽
* 工程 / 嵌入式首选
* 寄存器、协议、文件格式

---

### 2 至少宽度类型（Minimum-width）

```c
uint_least32_t
int_least16_t
```

含义：

* 至少这么多位
* 平台不支持精确类型时的兜底方案

---

### 3 最快类型（Fastest）

```c
uint_fast32_t
int_fast8_t
```

#### 含义：

* ≥ 指定位宽
* 在当前平台**访问最快**

---

## 10.5 最常见 typedef 类型速查表

| 类型       | 含义      |
| -------- | ------- |
| uint8_t  | 8 位无符号  |
| int8_t   | 8 位有符号  |
| uint16_t | 16 位无符号 |
| uint32_t | 32 位无符号 |
| uint64_t | 64 位无符号 |

---

## 10.6 在嵌入式中的典型用法（重点）

### 1 寄存器映射

```c
typedef struct {
    volatile uint32_t MODER;
    volatile uint32_t ODR;
} GPIO_TypeDef;
```

> 必须用 `uint32_t`，不能用 `int`

---

### 2 位操作

```c
uint32_t reg;
reg |= (1U << 5);
```

---

### 3 协议 / 数据帧

```c
typedef struct {
    uint8_t  head;
    uint16_t len;
    uint32_t crc;
} frame_t;
```

---

## 10.7 为什么不用 unsigned int？

```c
unsigned int reg;   // ❌ 不安全
uint32_t reg;       // ✅ 工程级
```

原因：

* `unsigned int` 位宽不确定
* 移植平台可能直接出 Bug

很重要的一点：

> `uint32_t` 不是编译器内建
> 
> 是标准库用 typedef 封装的

**C 语言的强大之处就在于“可被自己扩展”**

---

## 10.8 工程中常见的再封装

```c
typedef uint32_t u32;
typedef volatile uint32_t __IO;
```

这属于：

* 项目级 / 厂商级 typedef
* 建立在 `stdint.h` 之上

---

# 十一、常量

# 十二、运算符

# 十三、流程控制语句

# 十四、循环

# 十五、输入输出函数

# 十六、文件管理