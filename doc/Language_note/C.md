# C language

# 一、数据类型 (Data type)

C 语言是一门**强类型、贴近硬件的语言**

数据类型的本质是：**告诉编译器一段内存有多大、如何解释这段内存**

---

## 1.1 基本类型

### 1.1.1 char / short / int / long

| 类型    | 最小位宽（标准） | 常见位宽（32 位系统） |
| ----- | -------- | ------------ |
| char  | ≥ 8 bit  | 8 bit（1 字节）  |
| short | ≥ 16 bit | 16 bit（2 字节） |
| int   | ≥ short  | 32 bit（4 字节） |
| long  | ≥ int    | 32 或 64 bit  |

**注意**

* C 标准只规定**大小关系**，不规定具体字节数
* 实际大小**与平台、编译器有关**
* 嵌入式 / RISC-V / FPGA SoC 中尤为重要

```c
printf("char : %zu\n", sizeof(char));
printf("int  : %zu\n", sizeof(int));
```

---

### 1.1.2 signed / unsigned

#### （1）含义

* `signed`：有符号数（可表示正负）
* `unsigned`：无符号数（只表示非负）

```c
signed int a = -10;
unsigned int b = 10;
```

#### （2）取值范围差异（以 32 位 int 为例）

| 类型           | 范围           |
| ------------ | ------------ |
| signed int   | -2³¹ ~ 2³¹-1 |
| unsigned int | 0 ~ 2³²-1    |

**隐含规则**

* **整型默认是 signed**
* `char` 是否有符号由**编译器决定**（非常重要）

```c
char c = -1;   // 可能是 -1，也可能是 255
```

> **建议：明确写 signed / unsigned**

---

## 1.2 浮点类型

### 1.2.1 float / double

| 类型     | 常见大小 | 精度          |
| ------ | ---- | ----------- |
| float  | 4 字节 | ~6~7 位十进制   |
| double | 8 字节 | ~15~16 位十进制 |

```c
float  f = 3.14f;
double d = 3.14;
```

**注意**

* 浮点数在内存中不是精确值（IEEE 754）
* **不要直接用 `==` 比较浮点数**

```c
if (fabs(a - b) < 1e-6) { ... }
```

**嵌入式补充**

* 很多 MCU / 软核 **没有硬件浮点**
* 浮点运算 = 慢 + 代码大

---

## 1.3 派生类型

派生类型：**从基本类型“派生”出来的类型**

---

### 1.3.1 指针（pointer）

#### （1）定义

```c
int a = 10;
int *p = &a;
```

* `p` 保存的是 **a 的地址**
* `*p` 表示 **访问地址对应的值**

**核心公式**

> 指针 = 地址 + 类型

#### （2）指针大小

* **所有指针大小相同**
* 32 位系统：4 字节
* 64 位系统：8 字节

```c
sizeof(int*) == sizeof(char*)
```

---

### 1.3.2 数组（array）

```c
int arr[5] = {1,2,3,4,5};
```

* 数组是一段**连续的内存**
* `arr[i]` 等价于 `*(arr + i)`

**数组名的本质**

* 大多数情况下，数组名会退化为指向首元素的指针
* 但：

```c
sizeof(arr) != sizeof(&arr)
```

---

## 1.4 构造类型

### 1.4.1 struct（结构体）

结构体用于**组合不同类型的数据**

```c
struct Student {
    int id;
    char name[20];
};
```

* 成员按声明顺序存放
* 可能存在 **内存对齐**

```c
struct Student s;
```

---

### 1.4.2 union（共用体）

```c
union Data {
    int i;
    float f;
};
```

* 所有成员 **共用同一块内存**
* 大小 = 最大成员大小

📌 **特点**

* 同一时刻只能“正确使用”一个成员
* 常用于：

  * 协议解析
  * 寄存器映射

---

## 1.5 void 类型

### 1.5.1 void 的三种常见用法

#### （1）函数无返回值

```c
void func(void);
```

#### （2）通用指针

```c
void *p;
```

* `void*` 可以指向任何类型
* **不能直接解引用**

```c
int a = 10;
void *p = &a;
printf("%d", *(int*)p);
```

#### （3）函数参数为空

```c
int func(void);
```

---

## 1.6 sizeof 的本质（和平台有关）

### 1.6.1 sizeof 是什么

* **编译期运算符**
* 返回类型或对象所占的**字节数**

```c
sizeof(int)
sizeof(a)
```

> 注： **不是函数**

---

### 1.6.2 sizeof 与平台

| 平台   | 指针 | int | long |
| ---- | -- | --- | ---- |
| 32 位 | 4  | 4   | 4    |
| 64 位 | 8  | 4   | 8    |

#### **常见坑**

```c
int arr[10];
sizeof(arr);     // 40
sizeof(arr + 0); // 8（指针）
```

---

## 1.7 总结

> **C 语言的数据类型，本质是在“描述内存”和“如何解释内存”**

---

## 二、变量
### 2.1 变量的定义与声明
### 2.2 变量的作用域
  - 局部变量
  - 全局变量
### 2.3 生命周期
### 2.4 static 变量
### 2.5 extern 变量
### 2.6 volatile

---

# 二、变量 (Varible)

变量的本质是：

> **在内存中开辟一块空间，并给这块空间起一个名字**

理解变量，必须同时理解：

* **作用域（能在哪用）**
* **生命周期（什么时候存在）**
* **存储位置（在哪块内存）**

---

## 2.1 变量的定义与声明

### 2.1.1 变量定义（Definition）

**定义 = 分配内存**

```c
int a;
```

* 编译器为 `a` 分配内存空间
* 变量真正“存在”了

---

### 2.1.2 变量声明（Declaration）

**声明 = 告诉编译器变量存在，但不分配内存**

```c
extern int a;
```

### 2.1.3 核心区别

| 项目     | 定义 | 声明 |
| ------ | -- | -- |
| 是否分配内存 | ✅  | ❌  |
| 是否可多次  | ❌  | ✅  |

> **注意：**
> 
> * 普通 `int a;` 既是声明也是定义
> * `extern` 才是纯声明

---

## 2.2 变量的作用域（Scope）

作用域决定：

> **变量在代码中“能被访问的范围”**

---

### 2.2.1 局部变量

```c
void func(void)
{
    int x = 10;
}
```

* 定义在函数内部或代码块中
* 只能在所在代码块中使用

#### **特点**

* 存在于栈中
* 不初始化时是**随机值**

---

### 2.2.2 全局变量

```c
int g_val = 100;

void func(void)
{
    printf("%d", g_val);
}
```

* 定义在函数外
* 整个工程可见（需配合 `extern`）

#### **特点**

* 存放在 **全局区（.data / .bss）**
* 生命周期贯穿整个程序

---

## 2.3 生命周期（Lifetime）

生命周期描述的是：

> **变量从“创建”到“销毁”的时间**

---

### 2.3.1 局部变量生命周期

```c
void func(void)
{
    int a = 10;
}   // a 在这里被销毁
```

* 进入函数：创建
* 离开函数：销毁

> 注：**栈变量**

---

### 2.3.2 全局变量生命周期

```c
int g = 0;
```

* 程序开始 → 程序结束
* 始终存在

> 注：**与 main 是否执行无关**

---

## 2.4 static 变量（静态变量）

`static` 是 C 语言中**极其重要、极易混淆**的关键字。

---

### 2.4.1 static 修饰局部变量

```c
void func(void)
{
    static int cnt = 0;
    cnt++;
}
```

📌 **特点**

* 只初始化一次
* 生命周期 = 整个程序
* 作用域 = 该函数内部

#### **典型用途**

* 函数内部计数器
* 状态保持

---

### 2.4.2 static 修饰全局变量

```c
static int g_val = 10;
```

#### **特点**

* 作用域限制在当前 `.c` 文件
* 防止全局变量“污染”其他文件

#### **工程级最佳实践**

> 能 static 就 static

---

### 2.4.3 static 修饰函数

```c
static void helper(void)
{
}
```

* 函数仅在本文件可见
* 不会被其他文件链接

---

## 2.5 extern 变量

`extern` 用于：

> **在一个文件中使用另一个文件定义的变量**

---

### 2.5.1 使用方法

**a.c**

```c
int g_data = 100;
```

**b.c**

```c
extern int g_data;
```

---

### 2.5.2 extern 的本质

* 只是**声明**
* 不分配内存
* 由链接器解决符号

#### **常见错误**

```c
extern int x = 10;  // ❌ 这是定义，不是声明
```

---

## 2.6 volatile（嵌入式重点）

`volatile` 告诉编译器：

> **这个变量的值可能随时被“不可预知地改变”**

---

### 2.6.1 为什么需要 volatile

```c
while (flag == 0) {
}
```

如果 `flag` 没有 `volatile`：

* 编译器可能优化成死循环

---

### 2.6.2 volatile 的典型使用场景

1. **硬件寄存器**

```c
#define GPIO (*(volatile unsigned int*)0x40000000)
```

2. **中断共享变量**

```c
volatile int irq_flag;
```

3. **多线程 / 多核通信**

---

### 2.6.3 volatile 的限制

`volatile` **不能保证**

* 原子性
* 线程安全

只保证：

* **每次都从内存读写**

---

## 2.7 总结

| 关键字      | 作用         |
| -------- | ---------- |
| auto     | 默认局部变量     |
| static   | 改变生命周期或可见性 |
| extern   | 跨文件访问变量    |
| volatile | 禁止编译器优化    |

> **变量 = 名字 + 内存 + 作用域 + 生命周期**

---

# 三、函数 (Function)

函数的本质是：

> **一段可复用的代码 + 独立的栈帧 + 明确的输入输出**

理解函数，关键不在“会不会写”，而在：

* 参数是怎么传的
* 返回值从哪来
* 调用时内存发生了什么

---

## 3.1 函数定义与声明

### 3.1.1 函数定义（Definition）

```c
int add(int a, int b)
{
    return a + b;
}
```

函数定义包含：

* 返回类型
* 函数名
* 参数列表
* 函数体

> 注：**函数定义只能有一次**

---

### 3.1.2 函数声明（Declaration）

```c
int add(int a, int b);
```

作用：

* 告诉编译器函数的接口
* 不生成函数实体

> **声明可以多次**
> 
> 常放在 `.h` 文件中

---

### 3.1.3 函数声明与定义的关系

```c
int add(int a, int b);  // 声明

int main(void)
{
    add(1, 2);
}

int add(int a, int b)  // 定义
{
    return a + b;
}
```

---

## 3.2 参数传递

重要结论先给出

> **C 语言只有值传递，没有引用传递**

所谓“指针传递”，本质仍然是值传递。

---

### 3.2.1 值传递

```c
void func(int x)
{
    x = 100;
}

int main(void)
{
    int a = 10;
    func(a);
}
```

* `x` 是 `a` 的拷贝
* 修改 `x` 不影响 `a`

> 本质： **参数在栈上重新开辟空间**

---

### 3.2.2 指针传递（本质仍是值传递）

```c
void func(int *p)
{
    *p = 100;
}

int main(void)
{
    int a = 10;
    func(&a);
}
```

* 传的是 **地址的值**
* 通过地址修改了原变量

**记住这句话**

> 指针传递 = 地址的值传递

---

## 3.3 返回值

### 3.3.1 基本返回值

```c
int add(int a, int b)
{
    return a + b;
}
```

* 返回值通过寄存器传递（如 RISC-V：`a0`）
* `return` 会触发函数返回

---

### 3.3.2 返回指针（常见陷阱）

错误示例：

```c
int* func(void)
{
    int a = 10;
    return &a;  // ❌ 返回局部变量地址
}
```

原因：

* `a` 在栈上
* 函数返回后栈帧被销毁

---

### 3.3.3 正确返回方式

```c
static int a = 10;
return &a;
```

或

```c
int *p = malloc(sizeof(int));
return p;
```

---

## 3.4 栈帧（函数调用发生了什么）

这是**理解函数的关键部分**。

---

### 3.4.1 什么是栈帧（Stack Frame）

栈帧包含：

* 返回地址
* 参数
* 局部变量
* 保存的寄存器

**每调用一次函数，就创建一个栈帧**

---

### 3.4.2 函数调用流程（简化）

```text
caller:
  ↓ 压参数
  ↓ 保存返回地址
  ↓ 跳转到被调函数

callee:
  ↓ 创建栈帧
  ↓ 执行函数体
  ↓ 销毁栈帧
  ↓ 返回
```

> 递归本质 = 多个栈帧叠加

---

### 3.4.3 栈溢出

* 递归太深
* 局部数组太大

嵌入式中尤其危险

---

## 3.5 inline

`inline` 用于：

> **建议编译器将函数调用展开成代码**

---

### 3.5.1 使用方式

```c
inline int add(int a, int b)
{
    return a + b;
}
```

**注意**

* `inline` 是建议，不是强制
* 可能被编译器忽略

---

### 3.5.2 inline 的优缺点

#### 优点：

* 减少函数调用开销

#### 缺点：

* 增加代码体积
* 不利于调试

#### **嵌入式建议**

* 小函数
* 高频调用
* 放在 `.h`

---

## 3.6 递归

递归 = 函数调用自身。

---

### 3.6.1 递归三要素

1. 递归调用
2. 终止条件
3. 问题规模缩小

```c
int factorial(int n)
{
    if (n == 0)
        return 1;
    return n * factorial(n - 1);
}
```

---

### 3.6.2 递归的风险

* 占用大量栈空间
* 易导致栈溢出

> **嵌入式中慎用递归**

---

## 3.7 总结

| 项目     | 要点     |
| ------ | ------ |
| 参数传递   | 只有值传递  |
| 栈帧     | 每次调用独立 |
| 返回值    | 不返回栈地址 |
| inline | 建议，不保证 |
| 递归     | 本质是栈   |

> **函数调用 = 压栈 → 执行 → 出栈**

---

# 四、数组 (Array)

数组的本质一句话先给出：

> **数组 = 一段“连续、同类型、固定大小”的内存空间**

理解数组，关键不是下标，而是：

* 内存连续性
* 与指针的关系
* 在函数中的“退化行为”

---

## 4.1 一维数组

### 4.1.1 定义与初始化

```c
int arr[5];                  // 未初始化
int arr2[5] = {1,2,3,4,5};   // 完全初始化
int arr3[5] = {1,2};         // 部分初始化
```

**规则**

* 未显式初始化 → 值不确定（局部数组）
* 全局数组 / static 数组 → 默认初始化为 0

---

### 4.1.2 访问方式

```c
arr[i] == *(arr + i)
```

> **数组访问本质是指针运算**

---

### 4.1.3 数组类型

> 数组的类型 = 元素类型 + 元素个数

```ini
ArrayType = ElementType × Length
```

---

## 4.2 多维数组

### 4.2.1 定义

```c
int a[2][3] = {
    {1,2,3},
    {4,5,6}
};
```

* 本质是：**数组的数组**
* 每一行是一个一维数组

---

### 4.2.2 多维数组的存储顺序

C 语言使用 **行优先（Row-major）** 存储：

```text
a[0][0] a[0][1] a[0][2] a[1][0] a[1][1] a[1][2]
```

内存仍然是 **连续的一块**

---

### 4.2.3 多维数组的指针类型（容易错）

```c
int (*p)[3] = a;
```

* `p` 是 **指向“长度为 3 的 int 数组”的指针**
* 不是 `int**`

---

## 4.3 数组在内存中的布局

### 4.3.1 连续性

```c
int arr[4];
```

内存布局：

```
| arr[0] | arr[1] | arr[2] | arr[3] |
```

元素之间 **无空隙**

---

### 4.3.2 地址关系

```c
&arr[0] == arr
&arr[i] == arr + i
```

步长由 **元素类型决定**

---

### 4.3.3 数组与内存区域

| 数组类型          | 存储位置         |
| ------------- | ------------ |
| 局部数组          | 栈            |
| static / 全局数组 | .data / .bss |

---

## 4.4 数组名的本质

这是**本章最重要的一节**。

---

### 4.4.1 数组名 ≠ 普通变量

```c
int arr[10];
```

#### 数组名的三个特点：

1. 代表 **首元素地址**
2. **不能被赋值**
3. **不是左值**

```c
arr = other;   // ❌
```

---

### 4.4.2 数组名何时“退化”为指针？

在以下场景中：

* 作为函数参数
* 表达式中使用（非 sizeof / &）

```c
sizeof(arr);    // 数组总大小
sizeof(arr+0);  // 指针大小
```

---

### 4.4.3 &arr 的特殊性（进阶）

```c
&arr      // 类型：int (*)[10]
arr       // 类型：int*
```

步长不同：

* `arr + 1` → 移动一个元素
* `&arr + 1` → 跳过整个数组

---

## 4.5 数组作为函数参数

### 4.5.1 一维数组作为参数

```c
void func(int arr[])
```

等价于：

```c
void func(int *arr)
```

**数组作为参数会退化为指针**

---

### 4.5.2 sizeof 的陷阱

```c
void func(int arr[])
{
    sizeof(arr);  // ❌ 得到的是指针大小
}
```

**函数中无法获取数组真实长度**

---

### 4.5.3 正确传递数组长度

```c
void func(int *arr, int len)
{
}
```

---

### 4.5.4 多维数组作为参数（重点）

```c
void func(int arr[][3])
```

或

```c
void func(int (*arr)[3])
```

**除第一维外，其余维度必须明确**

---

## 4.6 总结

1. 数组名不是指针，但会退化
2. `sizeof(arr)` 和 `sizeof(arr[])` 结果不同
3. 多维数组 ≠ 二级指针
4. 数组越界是未定义行为

> **数组是“连续内存”，指针是“访问方式”**

---

# 五、指针 (Pin)

一句话先给出指针的本质：

> **指针 = 存储“地址”的变量 + 明确的类型**

理解指针，关键在两点：

1. 指针里存的是什么
2. 编译器如何用“指针类型”解释这块地址

---

## 5.1 指针的基本概念

### 5.1.1 什么是指针

```c
int a = 10;
int *p = &a;
```

* `a`：普通变量，存的是值
* `p`：指针变量，存的是 **a 的地址**
* `*p`：对地址解引用，访问地址里的内容

#### **三件事一定要分清**

* `a`：值
* `&a`：地址
* `*p`：地址对应的值

---

### 5.1.2 指针的类型

```c
int    *p1;
char   *p2;
double *p3;
```

**指针类型的意义**

* 决定：

  * 解引用时读多少字节
  * 指针加减的步长

> **指针类型 ≠ 地址大小**

---

## 5.2 指针与变量

### 5.2.1 指针指向变量

```c
int a = 10;
int *p = &a;
```

* `p` 指向 `a`
* 通过 `p` 可修改 `a`

```c
*p = 20;
```

---

### 5.2.2 指针作为变量本身

```c
int *p;
```

* `p` 本身也是变量
* 占用内存（4 / 8 字节）

**未初始化的指针是野指针**

---

## 5.3 指针与数组

这是**指针最重要、最容易混的关系**。

---

### 5.3.1 数组名与指针

```c
int arr[5];
int *p = arr;
```

说明：

* `arr` 退化为 `&arr[0]`
* `p` 指向数组首元素

---

### 5.3.2 指针访问数组

```c
p[i] == *(p + i)
```

**数组下标本质是指针运算**

---

### 5.3.3 指针 vs 数组（本质区别）

| 项目      | 数组    | 指针    |
| ------- | ----- | ----- |
| 是否可重新指向 | ❌     | ✅     |
| sizeof  | 整个数组  | 指针大小  |
| 内存分配    | 编译期固定 | 运行期可变 |

---

### 5.3.4 指向数组的指针（进阶）

```c
int (*p)[5];
```

* `p` 指向 **整个数组**
* 步长 = `sizeof(int[5])`

---

## 5.4 指针与函数

---

### 5.4.1 指针作为函数参数

```c
void func(int *p)
{
    *p = 100;
}
```

常用于：

* 修改实参
* 传递大对象
* 返回多个结果

---

### 5.4.2 函数返回指针

❌ 错误：

```c
int* func(void)
{
    int a = 10;
    return &a;
}
```

#### 为什么错？

`x` 是**栈变量**

函数返回后：栈帧销毁, `x`的内存无效, 返回的是悬空指针

返回栈变量地址 → 悬空指针

---

### 5.4.3 函数指针

```c
int add(int a, int b);
int (*fp)(int, int) = add;
```

用途：

* 回调函数
* 状态机
* 驱动接口

---

## 5.5 指针与结构体

### 5.5.1 结构体指针

```c
struct Student {
    int id;
};

struct Student s;
struct Student *p = &s;
```

---

### 5.5.2 `->` 运算符

```c
p->id == (*p).id
```

📌 **语法糖**

---

### 5.5.3 嵌入式中的典型用法

```c
#define UART0 ((volatile struct uart_reg *)0x40000000)
```

> **寄存器映射**

---

## 5.6 二级指针

### 5.6.1 定义

```c
int **pp;
```

* `pp` → 指向一个指针
* 常见于：

  * 修改指针本身
  * 动态二维数组
  * 参数输出

---

### 5.6.2 示例：修改指针

```c
void alloc(int **p)
{
    *p = malloc(sizeof(int));
}
```

---

## 5.7 野指针 / 悬空指针

### 5.7.1 野指针

```c
int *p;
```

* 未初始化
* 指向未知地址

---

### 5.7.2 悬空指针

```c
int *p = malloc(sizeof(int));
free(p);
// p 仍然指向已释放内存
```

---

### 5.7.3 预防方法

```c
p = NULL;
```

访问 NULL 可快速暴露错误

---

## 5.8 总结

1. 指针必须初始化
2. 不要返回栈地址
3. 指针类型必须匹配
4. 数组 ≠ 指针
5. 注意指针运算步长

> **指针不是“难”，而是“对内存的精确控制”**

---

# 六、结构体 (Struct)

## 6.1 结构体定义

### 1️⃣ 什么是结构体？

> **结构体是一种用户自定义类型，用来把“不同类型的数据”组合成一个整体。**

和数组的区别：

* 数组：同一类型
* 结构体：**不同类型**

---

### 2️⃣ 基本定义方式

```c
struct Person {
    int age;
    char gender;
    float height;
};
```

#### 说明：

* `struct Person` 是一种 **类型**
* 花括号里的是 **成员（member）**

---

### 3️⃣ 只定义结构体，不定义变量

```c
struct Student {
    int id;
    char name[20];
};
```

---

### 4️⃣ 定义结构体的同时定义变量

```c
struct Student {
    int id;
    char name[20];
} s1, s2;
```

---

## 6.2 结构体变量

### 1️⃣ 定义结构体变量

```c
struct Student s;
```

---

### 2️⃣ 成员访问（点运算符）

```c
s.id = 1001;
```

---

### 3️⃣ 初始化

```c
struct Student s = {1001, "Tom"};
```

或（推荐）：

```c
struct Student s = {
    .id = 1001,
    .name = "Tom"
};
```

**指定成员初始化**（工程强烈推荐）

---

## 6.3 结构体指针

### 1️⃣ 定义结构体指针

```c
struct Student *p;
```

---

### 2️⃣ 使用 `->` 访问成员

```c
p->id = 1001;
```

等价于：

```c
(*p).id = 1001;
```

📌 **`->` 本质是语法糖**

---

### 3️⃣ 结构体作为函数参数（推荐指针）

```c
void print_student(struct Student *s)
{
    printf("%d\n", s->id);
}
```

📌 避免大对象拷贝，提高效率

---

## 6.4 结构体内存对齐（重点）

### 1️⃣ 为什么要内存对齐？

> 为了提高 CPU 访问效率
> 某些架构 **不对齐访问会直接异常（嵌入式非常常见）**

---

### 2️⃣ 对齐规则（必背）

1. 成员按声明顺序排列
2. 每个成员起始地址是：

   ```
   min(成员大小, 对齐单位) 的整数倍
   ```
3. 结构体总大小是 **最大对齐值的整数倍**

---

### 3️⃣ 示例（非常重要）

```c
struct A {
    char a;   // 1
    int  b;   // 4
    char c;   // 1
};
```

内存布局：

```text
偏移
0   a
1   padding
2   padding
3   padding
4   b
5   b
6   b
7   b
8   c
9   padding
10  padding
11  padding
```

```c
sizeof(struct A) == 12
```

---

### 4️⃣ 控制对齐（嵌入式常用）

```c
#pragma pack(1)
struct B {
    char a;
    int b;
};
#pragma pack()
```

⚠️ **慎用，可能影响性能**

---

## 6.5 typedef struct

### 1️⃣ 为什么要用 typedef？

```c
struct Student s;
```

太长，不利于工程维护。

---

### 2️⃣ 常见写法（推荐）

```c
typedef struct {
    int id;
    char name[20];
} Student;
```

使用：

```c
Student s;
Student *p;
```

📌 **这是嵌入式/驱动代码的标配写法**

---

### 3️⃣ 另一种写法（保留 tag）

```c
typedef struct Student {
    int id;
} Student;
```

---

## 6.6 结构体在嵌入式中的应用

### 6.6.1 寄存器映射（核心重点）

> **用结构体“描述硬件寄存器布局”**

---

### 示例：GPIO 寄存器映射

```c
typedef struct {
    volatile uint32_t MODER;
    volatile uint32_t OTYPER;
    volatile uint32_t OSPEEDR;
    volatile uint32_t PUPDR;
    volatile uint32_t IDR;
    volatile uint32_t ODR;
} GPIO_TypeDef;
```

---

### 寄存器基地址

```c
#define GPIOA_BASE 0x40020000
```

---

### 映射成结构体指针

```c
#define GPIOA ((GPIO_TypeDef *)GPIOA_BASE)
```

---

### 使用方式（非常优雅）

```c
GPIOA->MODER = 0x55555555;
```

### **本质：**

* 把硬件地址当成结构体
* 通过指针访问成员
* 编译器自动帮你算偏移

---

### 6.6.2 为什么成员要 volatile？

```c
volatile uint32_t ODR;
```

防止编译器优化：

* 硬件寄存器可能“随时变”
* 每次访问都必须真实读写

---

## 6.7 总结

> * 结构体是异构数据的组合
> * 指针 + 结构体是工程核心
> * 内存对齐直接影响性能和正确性
> * 寄存器映射是嵌入式 C 的灵魂

---

# 七、枚举 (enum)

## 7.1 enum 的定义

```c
enum Color {
    RED,
    GREEN,
    BLUE
};
```

* `RED = 0`
* `GREEN = 1`
* `BLUE = 2`

>  默认从 **0 开始，依次 +1**

---

## 7.2 enum 的本质（非常重要）

> **enum 本质上是一个“整型常量集合”**

* 底层类型：**int（或能容纳的最小整型，编译器决定）**
* **不是真正的新类型**
* 编译后：没有 enum 这个概念，只有整数

```c
enum Color c = RED;
```

等价于：

```c
int c = 0;
```

---

## 7.3 显式赋值

```c
enum State {
    IDLE = 0,
    RUN  = 3,
    STOP = 10
};
```

后面的成员如果没指定：

```c
STOP = 10
NEXT = 11
```

---

## 7.4 enum 的作用（为什么要用）

### 1️⃣ 提高可读性

```c
if (state == RUN)   // 好
if (state == 3)     // 差
```

---

### 2️⃣ 代替宏常量（更安全）

```c
#define RUN 3        // 无类型
enum { RUN = 3 };   // 有作用域
```

---

## 7.5 enum 与 switch（经典组合）

```c
switch (state) {
case IDLE:
    break;
case RUN:
    break;
}
```

注：**状态机核心写法**

---

## 7.6 typedef enum（工程中最常见）

```c
typedef enum {
    IDLE,
    RUN,
    STOP
} state_t;

state_t s;
```

✔️ **这是工业级写法**

---

### 7.7 enum 的常见误区

> enum 会限制取值范围？
> 
> **不会**

```c
state_t s = 100;   // 编译器通常不报错
```

- enum 占 1 字节？

- **通常占 int 大小**

---

# 八、共用体 (union)

## 8.1 union 的定义

```c
union Data {
    int   i;
    float f;
    char  c[4];
};
```

---

## 8.2 union 的核心本质（必须牢记）

> **所有成员共享同一块内存**

* 大小 = **最大成员的大小**
* 同一时间，只能“逻辑上”使用一个成员

```c
union Data d;
```

内存示意：

```text
| 4 bytes |
```

---

## 8.3 union 的内存大小

```c
sizeof(union Data) == max(sizeof(int), sizeof(float), sizeof(char[4]))
```

对齐后可能更大

---

## 8.4 union 的读写行为（重点）

```c
union Data d;
d.i = 0x3f800000;
printf("%f", d.f);
```

 **按位重解释（type punning）**

---

## 8.5 union 的典型用途

#### 1️⃣ 不同数据格式的“视角切换”

```c
union {
    uint32_t val;
    uint8_t  byte[4];
} u;
```

用途：

* 大小端分析
* 通信协议解析

---

#### 2️⃣ 节省内存（嵌入式）

```c
union {
    int  temp;
    char buf[64];
} u;
```

同一时刻只用一种数据

---

## 8.6 union + struct（工程经典）

```c
typedef union {
    uint32_t value;
    struct {
        uint32_t EN  : 1;
        uint32_t MODE: 2;
        uint32_t RES : 29;
    } bit;
} REG_t;
```

**寄存器映射神器**

---

## 8.7 union 的危险点

写的是 `i`，却读 `f`

```c
d.i = 10;
printf("%f", d.f);  // 未定义/依赖实现
```

除非你明确是“按位解释”

---

## 8.8 enum + union 的经典组合（状态数据）

```c
typedef enum {
    TYPE_INT,
    TYPE_FLOAT
} type_t;

typedef struct {
    type_t type;
    union {
        int   i;
        float f;
    } data;
} value_t;
```

使用：

```c
value_t v;
v.type = TYPE_INT;
v.data.i = 10;
```

 **C 语言实现“变体类型”的标准方式**

---

## 8.9 enum vs union vs struct 对比总结

| 类型     | 核心作用             |
| ------ | ---------------- |
| enum   | **整数语义化（状态/模式）** |
| struct | **同时存在的成员**      |
| union  | **互斥存在的成员（省内存）** |

---

# 九、内存与编译 (Memory & Complie)

## 9.1 栈 / 堆 / 全局区 / 代码区 （四区）

### 9.1.1 程序运行时的内存整体布局（逻辑视角）

典型进程内存模型（从低地址到高地址）：

```text
.text      （代码段）
.rodata    （只读数据）
.data      （已初始化全局变量）
.bss       （未初始化全局变量）
heap       （堆，向上增长）
↓
↑
stack      （栈，向下增长）
```

注：上图描述的是“典型进程的虚拟地址的空间布局”

具体情况是操作系统、编译器、链接脚本的共同决定结果

---

### 9.1.2 栈（Stack）

#### 特点：

* 自动分配、自动释放
* 每次函数调用都会创建 **栈帧**
* 速度快，空间有限

#### 存放内容：

* 局部变量
* 函数参数
* 返回地址
* 保存的寄存器

```c
void func(void)
{
    int a = 10;   // 栈上
}
```

⚠️ 问题：

* 栈溢出（递归过深、大数组）

---

### 9.1.3 堆（Heap）

特点：

* 手动申请 / 手动释放
* 生命周期由程序员控制
* 空间大但速度慢

```c
int *p = malloc(sizeof(int));  // 堆
```

⚠️ 常见问题：

* 内存泄漏
* 野指针
* 碎片化（嵌入式尤为严重）

---

### 9.1.4 全局区（静态区）

存放：

* 全局变量
* static 变量（静态变量）
* 具有静态存储期的常量
  - 全局 const
  - static const

* 常见段
  - `.data`，
  - `.bss`，
  - `.rodata`

```c
int g = 10;          // .data
static int s;        // .bss
```

特点：

* 程序启动时分配
* 程序结束时释放

### 9.1.5 代码区

存放：

* 程序的可执行指令 **（二进制代码）**
  - 各函数的机器指令
  - 启动代码
  - 编译器生成的辅助代码

> 本质：CPU实际取指运行的地方

* 常见段：
  - `.text`
  - `.init`
  - `.vectors`

特点
* 只读
* 共享
* 可执行，在整个程序生命周期一直存在

---

## 9.2 malloc / free原理

### 9.2.1 malloc 是干嘛的？

```c
void *malloc(size_t size);
```

> 向 **堆** 申请一块连续内存

---

### 9.2.2 malloc 的本质

> malloc 本身不是系统调用
> 
> 它是 **C 库对底层内存管理的封装**

底层可能使用：

* `brk / sbrk`
* `mmap`
* 或嵌入式里的 **静态内存池**

---

### 9.2.3 malloc 内部做了什么？

简化流程：

```text
1. 查找空闲内存块
2. 若足够大 → 切割
3. 标记为已占用
4. 返回指针
```

---

### 9.2.4 free 的本质

```c
free(p);
```

只是把内存标记为“可复用”, 并不一定立刻归还给 OS

---

### 9.2.5 嵌入式里的现实问题

⚠️ 很多嵌入式项目：

* 禁用 malloc/free
* 使用静态内存池

原因：

* 内存碎片
* 不可预测性

---

## 9.3 .text / .data / .bss（编译 & 链接视角）

这是 **编译器 + 链接器眼里的程序**

---

### 9.3.1 .text 段（代码段）

存放：

* 机器指令
* 通常只读

```c
int add(int a, int b)
{
    return a + b;
}
```

👉 在 `.text`

---

### 9.3.2 .data 段（已初始化全局数据）

特点：

* 有初始值
* 占用 Flash + RAM

```c
int g = 10;
static int s = 5;
```

---

### 9.3.3 .bss 段（未初始化全局数据）

特点：

* 初始值默认为 0
* **不占 Flash**
* 启动时清零

```c
int g;
static int s;
```

---

### 9.3.4 .rodata（只读数据）

存放：

* 字符串常量
* const 全局变量

```c
const char *s = "hello";
```

---

### 9.3.5 一个非常重要的对比

| 段       | 占 Flash | 占 RAM |
| ------- | ------- | ----- |
| .text   | ✅       | ❌     |
| .rodata | ✅       | ❌     |
| .data   | ✅       | ✅     |
| .bss    | ❌       | ✅     |

---

## 9.4 ELF 文件结构（程序文件本体）

### 9.4.1 什么是 ELF？

> **ELF（Executable and Linkable Format）**
> 是 Linux / 嵌入式下最常见的可执行文件格式

---

### 9.4.2 ELF 的主要组成

```text
ELF Header
Program Header Table
Section Header Table
Sections（.text .data .bss …）
```

---

### 9.4.3 Section vs Segment（重点）

| 概念      | 用途    |
| ------- | ----- |
| Section | 给链接器用 |
| Segment | 给加载器用 |

Section 会被“打包”成 Segment

---

### 9.4.4 常见 section

| Section | 作用     |
| ------- | ------ |
| .text   | 代码     |
| .data   | 已初始化数据 |
| .bss    | 未初始化数据 |
| .rodata | 常量     |
| .symtab | 符号表    |
| .strtab | 字符串表   |

---

### 9.4.5 工程实践

```bash
readelf -h a.out
readelf -S a.out
objdump -h a.out
```

---

## 9.5 一个“全链路”理解（非常重要）

```text
.c
 ↓ 编译
.o        （section 级）
 ↓ 链接
ELF       （section + segment）
 ↓ 加载
内存布局（text / data / bss / heap / stack）
```

---

## 9.6 总结

* 栈用于函数调用，堆用于动态分配
* 全局变量位于 data / bss
* .text / .data / .bss 是编译链接视角
* 栈 / 堆 是运行时视角
* ELF 是程序在磁盘上的最终形态

---

# 十、数据类型进阶版 (typedef优化后的)

## 10.1 这些类型是什么？

像下面这些：

```c
uint8_t   uint16_t   uint32_t   uint64_t
int8_t    int16_t    int32_t    int64_t
```

它们不是 C 语言“原生关键字”，而是：

> **通过 typedef 定义的、具有“确定字长”的整数类型**

---

## 10.2  它们从哪里来？

### 1️⃣ 定义在标准头文件中

```c
#include <stdint.h>
```

这是 **C99 标准**引入的头文件。

---

### 2️⃣ 本质是 typedef

在 `<stdint.h>` 里（简化理解）：

```c
typedef unsigned int  uint32_t;
typedef signed int    int32_t;
```

实际映射取决于平台，但标准保证：

> `uint32_t` **一定是 32 位无符号整数**

---

## 10.3 为什么 C 标准要“人为定义”这些类型？

### 1️⃣ 因为 C 的基础类型大小不固定

| 类型    | 大小是否固定  |
| ----- | ------- |
| char  | ≥ 1 字节  |
| short | ≥ char  |
| int   | ≥ short |
| long  | ≥ int   |

**没有任何一条保证 int = 32 位**

---

### 2️⃣ 但工程世界需要“绝对确定”

* 寄存器：32 bit
* 协议字段：16 bit
* 文件格式：8 / 32 bit
* 网络包：bit 级对齐

👉 **不能靠 int 碰运气**

---

## 10.4 标准整数类型的分类（非常重要）

### 1 精确宽度类型（Exact-width）

> **如果平台支持，才定义**

```c
uint8_t   int8_t
uint16_t  int16_t
uint32_t  int32_t
uint64_t  int64_t
```

#### 特点：

* 精确位宽
* 工程 / 嵌入式首选
* 寄存器、协议、文件格式

---

### 2 至少宽度类型（Minimum-width）

```c
uint_least32_t
int_least16_t
```

含义：

* 至少这么多位
* 平台不支持精确类型时的兜底方案

---

### 3 最快类型（Fastest）

```c
uint_fast32_t
int_fast8_t
```

#### 含义：

* ≥ 指定位宽
* 在当前平台**访问最快**

---

## 10.5 最常见 typedef 类型速查表

| 类型       | 含义      |
| -------- | ------- |
| uint8_t  | 8 位无符号  |
| int8_t   | 8 位有符号  |
| uint16_t | 16 位无符号 |
| uint32_t | 32 位无符号 |
| uint64_t | 64 位无符号 |

---

## 10.6 在嵌入式中的典型用法（重点）

### 1 寄存器映射

```c
typedef struct {
    volatile uint32_t MODER;
    volatile uint32_t ODR;
} GPIO_TypeDef;
```

> 必须用 `uint32_t`，不能用 `int`

---

### 2 位操作

```c
uint32_t reg;
reg |= (1U << 5);
```

---

### 3 协议 / 数据帧

```c
typedef struct {
    uint8_t  head;
    uint16_t len;
    uint32_t crc;
} frame_t;
```

---

## 10.7 为什么不用 unsigned int？

```c
unsigned int reg;   // ❌ 不安全
uint32_t reg;       // ✅ 工程级
```

原因：

* `unsigned int` 位宽不确定
* 移植平台可能直接出 Bug

很重要的一点：

> `uint32_t` 不是编译器内建
> 
> 是标准库用 typedef 封装的

**C 语言的强大之处就在于“可被自己扩展”**

---

## 10.8 工程中常见的再封装

```c
typedef uint32_t u32;
typedef volatile uint32_t __IO;
```

这属于：

* 项目级 / 厂商级 typedef
* 建立在 `stdint.h` 之上

---

# 十一、常量（Constants）

## 11.1 常量的概念

### 1. 什么是常量

**常量（Constant）** 是指在程序运行期间**值不能被改变**的数据。

> 与变量（Variable）相对
> 变量：值可以改变
> 常量：值固定不变

```c
10          // 常量
3.14        // 常量
'a'         // 常量
"hello"     // 常量
```

---

### 2. 常量的特点

* 值在**编译期或运行期确定**
* **不可修改**
* 通常直接写在代码中（字面量）
* 用于：

  * 表示固定值（如 π、最大长度）
  * 增强代码可读性
  * 避免“魔法数字（Magic Number）”

---

## 11.2 常量的分类（按表现形式）

C 语言中的常量主要分为以下几类：

---

### 11.2.1 整型常量（Integer Constant）

#### 1. 十进制

```c
10
-20
0
```

#### 2. 八进制（以 `0` 开头）

```c
012   // 十进制 10
```

#### 3. 十六进制（以 `0x` / `0X` 开头）

```c
0xA    // 十进制 10
0XFF
```

> ⚠️ **注意**

```c
int x = 012;   // 不是12，是10
```

---

### 11.2.2 浮点常量（Floating Constant）

#### 1. 十进制形式

```c
3.14
-0.01
```

#### 2. 科学计数法

```c
1.23e3    // 1230
1e-3      // 0.001
```

#### 3. 默认类型

* `3.14` → `double`
* `3.14f` → `float`

---

### 11.2.3 字符常量（Character Constant）

#### 1. 普通字符常量

```c
'a'
'Z'
'0'
```

> 字符常量本质是 **整数（ASCII 码）**

```c
printf("%d\n", 'A');   // 输出 65
```

---

#### 2. 转义字符常量

| 转义字符 | 含义    |
| ---- | ----- |
| `\n` | 换行    |
| `\t` | 制表符   |
| `\0` | 字符串结束 |
| `\\` | 反斜杠   |
| `\'` | 单引号   |
| `\"` | 双引号   |

```c
char c = '\n';
```

---

### 11.2.4 字符串常量（String Literal）

```c
"hello"
"abc\n"
""
```

#### 特点

* 字符串本质是 **字符数组**
* 末尾自动包含 `'\0'`

```c
char s[] = "abc";    // {'a','b','c','\0'}
```

⚠️ **字符串常量不可修改**

```c
char *p = "hello";
p[0] = 'H';   // ❌ 未定义行为
```

---

### 11.2.5 枚举常量（Enum Constant）

```c
enum Color {
    RED,
    GREEN,
    BLUE
};
```

* 本质是 **整型常量**
* 默认从 `0` 开始递增

```c
RED == 0
GREEN == 1
```

---

## 11.3 常量的定义方式（语义层面）

### 11.3.1 字面常量（Literal）

直接写在代码里的常量：

```c
int a = 10;
float b = 3.14;
```

优点：简单
缺点：不易维护（魔法数字）

---

### 11.3.2 宏常量（`#define`）

```c
#define PI 3.1415926
#define MAX_LEN 128
```

特点：

* **预处理阶段**替换
* 不占内存
* 无类型检查

```c
#define SQR(x) x*x   // ❌ 容易出错
```

正确写法：

```c
#define SQR(x) ((x)*(x))
```

---

### 11.3.3 `const` 常量（重点）

```c
const int a = 10;
```

特点：

* 有类型
* 受编译器检查
* 推荐使用

```c
const int MAX = 100;
```

---

#### const 与变量的区别

```c
const int x = 10;
x = 20;   // ❌ 编译错误
```

⚠️ **const ≠ 真正的常量（在 C 中）**

```c
int a = 10;
const int b = a;   // 合法
```

---

## 11.4 const 的本质理解（进阶）

### 1. const 修饰的是“访问权限”

```c
const int x = 10;  // x 只读
```

但底层内存仍然存在

---

### 2. const 与指针（极易考）

```c
const int *p;   // 指针指向的内容不能改
int * const p;  // 指针本身不能改
const int * const p; // 都不能改
```

口诀：

> **const 看右边，修饰最近的东西**

---

## 11.5 常量的作用域与生命周期

* 字面量：编译期存在
* 宏常量：预处理期替换
* const 常量：与变量一致（栈 / 静态区）

```c
void func() {
    const int x = 10;   // 栈
}
```

---

## 11.6 常见错误与易混点

### 1. 修改字符串常量

```c
char *p = "abc";
p[0] = 'A';   // ❌
```

---

### 2. const 与 define 混用不清

| 对比   | const | #define |
| ---- | ----- | ------- |
| 类型检查 | 有     | 无       |
| 调试   | 可见    | 不可见     |
| 作用域  | 有     | 全局      |

---

### 3. 魔法数字问题

```c
if (x > 1024)   // ❌
```

推荐：

```c
#define MAX_SIZE 1024
```

或

```c
const int MAX_SIZE = 1024;
```

---

## 11.7 工程实践建议

✅ **优先使用 `const`**

✅ 宏只用于：

* 条件编译
* 平台相关
* 简单常量

✅ 复杂表达式慎用宏

---

## 11.8 总结

> * 常量是值不可变的数据
> * 常见常量：整型、浮点、字符、字符串、枚举
> * `#define` 是预处理替换
> * `const` 是类型安全的只读变量
> * 字符串常量不可修改
> * const 与指针是高频考点

---

# 十二、运算符（Operators）

## 12.1 运算符概述

### 1. 什么是运算符

**运算符（Operator）** 是用于对数据进行**计算、比较、逻辑判断、位操作**等操作的符号。

```c
a + b      // + 是运算符
a = 10     // = 是运算符
```

---

### 2. 运算符与操作数

```c
a + b
```

* `+`：运算符
* `a`、`b`：操作数

---

### 3. 运算符分类（总览）

| 分类     | 运算符                    |            |    |
| ------ | ---------------------- | ---------- | -- |
| 算术运算符  | `+ - * / %`            |            |    |
| 关系运算符  | `> < >= <= == !=`      |            |    |
| 逻辑运算符  | `&&                    |            | !` |
| 位运算符   | `&                     | ^ ~ << >>` |    |
| 赋值运算符  | `= += -= *= /= %= ...` |            |    |
| 自增自减   | `++ --`                |            |    |
| 条件运算符  | `?:`                   |            |    |
| sizeof | `sizeof`               |            |    |
| 逗号运算符  | `,`                    |            |    |
| 类型转换   | `(type)`               |            |    |

---

## 12.2 算术运算符

### 12.2.1 基本算术运算符

| 运算符 | 含义     |
| --- | ------ |
| `+` | 加      |
| `-` | 减      |
| `*` | 乘      |
| `/` | 除      |
| `%` | 取模（余数） |

```c
int a = 10, b = 3;
a + b;   // 13
a / b;   // 3（整数除法）
a % b;   // 1
```

---

### 12.2.2 整数除法规则

```c
5 / 2    // 2
5 / 2.0  // 2.5
```

> ⚠️ 两个整数相除 → 结果仍为整数

---

### 12.2.3 取模运算符 `%`

* **只能用于整数**
* 结果符号与 **被除数** 相同（C99 以后）

```c
-7 % 3   // -1
```

---

## 12.3 自增 / 自减运算符

### 12.3.1 前置与后置

```c
++i   // 先加后用
i++   // 先用后加
```

```c
int i = 5;
printf("%d\n", i++); // 5
printf("%d\n", ++i); // 7
```

---

### 12.3.2 易错点（高频）

```c
i = i++;    // ❌ 未定义行为
```

> 同一表达式中多次修改同一变量 → 未定义行为

---

## 12.4 赋值运算符

### 12.4.1 基本赋值

```c
a = 10;
```

### 12.4.2 复合赋值

```c
a += 5;   // a = a + 5
a <<= 1;  // a = a << 1
```

---

### 12.4.3 赋值表达式有返回值

```c
if ( (a = b) > 0 ) {
    ...
}
```

⚠️ 易与 `==` 混淆

---

## 12.5 关系运算符

| 运算符       | 含义          |
| --------- | ----------- |
| `>` `<`   | 大于 / 小于     |
| `>=` `<=` | 大于等于 / 小于等于 |
| `==`      | 等于          |
| `!=`      | 不等于         |

```c
a > b
a == b
```

返回值：

* **真：1**
* **假：0**

---

### 常见错误

```c
if (a = 5)   // ❌
```

应为：

```c
if (a == 5)
```

---

## 12.6 逻辑运算符

### 12.6.1 三大逻辑运算符

| 运算符  | 含义  |   |     |
| ---- | --- | - | --- |
| `&&` | 逻辑与 |   |     |
| `    |     | ` | 逻辑或 |
| `!`  | 逻辑非 |   |     |

---

### 12.6.2 短路求值（重点）

```c
a && b   // a 为假 → b 不执行
a || b   // a 为真 → b 不执行
```

工程意义：

* 防止空指针
* 提高效率

```c
if (p != NULL && p->x > 0) { ... }
```

---

## 12.7 位运算符（嵌入式 / 底层必会）

| 运算符  | 含义  |     |
| ---- | --- | --- |
| `&`  | 按位与 |     |
| `    | `   | 按位或 |
| `^`  | 异或  |     |
| `~`  | 取反  |     |
| `<<` | 左移  |     |
| `>>` | 右移  |     |

---

### 12.7.1 常见用途

#### 1. 位掩码

```c
#define BIT0 (1 << 0)

if (x & BIT0) { ... }
```

---

#### 2. 清零 / 置位

```c
x |= (1 << 3);   // 置位
x &= ~(1 << 3);  // 清零
```

---

### 12.7.2 移位注意事项

* 左移可能溢出
* 右移：

  * 有符号数：算术移位（实现相关）
  * 无符号数：逻辑移位

---

## 12.8 条件运算符（三目运算符）

```c
条件 ? 表达式1 : 表达式2;
```

```c
int max = (a > b) ? a : b;
```

特点：

* 唯一三目运算符
* 有返回值

---

## 12.9 sizeof 运算符

```c
sizeof(int)
sizeof a
```

特点：

* 编译期计算（大多数情况）
* 返回 `size_t`

```c
printf("%zu\n", sizeof(int));
```

---

### sizeof 与数组

```c
int arr[10];
sizeof(arr);        // 40
sizeof(arr[0]);     // 4
```

⚠️ 传参后退化为指针

---

## 12.10 类型转换运算符

### 12.10.1 隐式类型转换

```c
int + double → double
```

---

### 12.10.2 强制类型转换

```c
(int)3.14   // 3
```

⚠️ 强转不改变内存，只改变解释方式

---

## 12.11 逗号运算符

```c
int a = (b = 3, b + 2);  // a = 5
```

* 从左到右执行
* 返回最后一个表达式的值

---

## 12.12 运算符优先级（概念）

> **优先级 ≠ 执行顺序**

建议：

* 不记表
* 多用括号

```c
a + b * c
(a + b) * c
```

---

## 12.13 常见未定义行为（重点）

```c
i = i++;
a[i] = i++;
```

原因：

* 同一序列点多次修改

---

## 12.14 工程实践建议

✅ 多用括号提高可读性
✅ 位运算用于底层与性能关键处
✅ 避免在一个表达式中多次修改同一变量
✅ 条件判断防止误用 `=`

---

## 12.15 总结

> * 运算符是 C 的核心表达能力
> * 逻辑运算符支持短路
> * 位运算是底层编程基础
> * `sizeof` 在数组和指针上差异巨大
> * 自增自减是未定义行为高发区

---

# 十三、流程控制语句（Control Flow Statements）

## 13.1 流程控制概述

流程控制语句决定程序的执行路径，影响程序是否执行、执行多少次或执行哪个分支。是程序逻辑的核心。

---

## 13.2 条件语句

### 13.2.1 `if` 语句

```c
if (condition) {
    // 条件为真执行
}
```

* 条件表达式非零为真，零为假
* 可以没有 `{}`，但不推荐

---

### 13.2.2 `if-else` 语句

```c
if (condition) {
    // 条件为真
} else {
    // 条件为假
}
```

---

### 13.2.3 `if-else if-else` 多分支

```c
if (cond1) {
    // ...
} else if (cond2) {
    // ...
} else {
    // 其他情况
}
```

---

### 13.2.4 条件表达式（?:）运算符（可作为简写）

```c
int max = (a > b) ? a : b;
```

---

## 13.3 `switch` 语句

### 13.3.1 基本语法

```c
switch (表达式) {
    case 常量1:
        // 代码
        break;
    case 常量2:
        // 代码
        break;
    default:
        // 默认代码
}
```

---

### 13.3.2 工作机制

* 表达式结果与 `case` 标签匹配则执行对应代码
* **`break`** 防止“穿透”到后续 `case`
* `default` 可选，匹配不到任何 `case` 时执行

---

### 13.3.3 注意事项

* `case` 后必须是**常量表达式**
* `switch` 只能用于**整数类型**（`char`、`int`、`enum`）
* 防止忘写 `break` 导致“穿透”错误

---

## 13.4 循环语句

### 13.4.1 `while` 循环

```c
while (condition) {
    // 条件为真执行循环体
}
```

* 条件为假则结束循环
* 先判断，可能一次都不执行

---

### 13.4.2 `do-while` 循环

```c
do {
    // 循环体
} while (condition);
```

* 先执行一次循环体，再判断条件
* 至少执行一次


---

### 13.4.3 `for` 循环

```c
for (初始化; 条件; 更新) {
    // 循环体
}
```

等价于：

```c
初始化;
while (条件) {
    // 循环体
    更新;
}
```

---

### 13.4.4 无限循环示例

```c
while(1) { ... }
for(;;) { ... }
```

---

## 13.5 循环控制语句

### 13.5.1 `break`

* 立即终止最近的循环或 `switch`
* 跳出循环体，继续执行后续代码

---

### 13.5.2 `continue`

* 跳过本次循环剩余语句，进入下一次循环判断

---

### 13.5.3 `goto`（谨慎使用）

```c
goto label;
...
label:
    // 代码
```

* 无条件跳转
* 可能导致代码难读，通常避免使用

---

## 13.6 流程控制语句的注意点与常见错误

| 问题                        | 说明         | 解决建议                  |
| ------------------------- | ---------- | --------------------- |
| 忘写 `break` 导致 `switch` 穿透 | 多数新手易错     | 每个 `case` 尾部写 `break` |
| 条件表达式非布尔值理解偏差             | C中非零为真，零为假 | 明确理解条件表达式含义           |
| 循环出口条件不正确                 | 死循环或未执行    | 仔细设计循环条件和更新语句         |
| `goto` 使用过滥               | 代码难读、难维护   | 尽量用结构化语句替代            |

---

## 13.7 工程实践建议

✅ 逻辑复杂时用`switch`代替多层`if-else`，更清晰
✅ 使用`for`循环时，循环变量的作用域尽量局限在循环体内
✅ 使用`continue`避免多层嵌套，提升代码可读性
✅ 谨慎使用`goto`，一般用于错误处理或跳出多层循环
✅ 写代码时，**良好缩进和注释**是保证流程清晰的关键

---

## 13.8 总结

> * `if-else` 是最基本的分支语句
> * `switch` 用于多分支，注意`break`防止穿透
> * `for`、`while`、`do-while`满足不同循环需求
> * `break`和`continue`控制循环执行流程
> * `goto`使用需谨慎，避免代码混乱

---

# 十四、输入输出函数（Input/Output Functions）

## 14.1 输入输出概述

C语言通过标准库提供了一组输入输出函数，主要用于与用户交互，读取输入数据和显示输出结果。

---

## 14.2 标准输入输出库 `<stdio.h>`

### 14.2.1 常用函数分类

| 功能     | 函数示例                                         | 说明         |
| ------ | -------------------------------------------- | ---------- |
| 输出     | `printf()`, `puts()`, `putchar()`            | 格式化和非格式化输出 |
| 输入     | `scanf()`, `gets()` (弃用), `getchar()`        | 格式化和非格式化输入 |
| 文件输入输出 | `fopen()`, `fclose()`, `fread()`, `fwrite()` | 文件操作相关     |

---

## 14.3 标准输出函数

### 14.3.1 `printf()` — 格式化输出

```c
int printf(const char *format, ...);
```

* 格式字符串 + 可变参数
* 返回打印字符数

---

### 14.3.2 格式控制字符串

| 格式符  | 说明        | 示例             |
| ---- | --------- | -------------- |
| `%d` | 有符号十进制整数  | `%d` → 123     |
| `%u` | 无符号十进制整数  | `%u` → 123     |
| `%f` | 浮点数       | `%f` → 3.14    |
| `%c` | 字符        | `%c` → 'A'     |
| `%s` | 字符串       | `%s` → "hello" |
| `%x` | 十六进制（小写）  | `%x` → `1a`    |
| `%X` | 十六进制（大写）  | `%X` → `1A`    |
| `%%` | 输出 `%` 字符 | `%%` → `%`     |

---

### 14.3.3 格式控制的修饰符

| 修饰符      | 作用                    | 示例              |
| -------- | --------------------- | --------------- |
| `-`      | 左对齐                   | `%-10d`         |
| `数字`     | 指定字段宽度                | `%10d`          |
| `.数字`    | 指定小数点后位数（浮点数）或最大字符串长度 | `%.2f` `%10.5s` |
| `l`、`ll` | 长整型修饰符                | `%ld` `%lld`    |

---

### 14.3.4 其他输出函数

| 函数                    | 说明         |
| --------------------- | ---------- |
| `puts(const char *s)` | 输出字符串 + 换行 |
| `putchar(int c)`      | 输出单个字符     |

---

## 14.4 标准输入函数

### 14.4.1 `scanf()` — 格式化输入

```c
int scanf(const char *format, ...);
```

* 读取并格式化输入数据
* 返回成功匹配的参数个数

---

### 14.4.2 `scanf` 格式控制符

同 `printf`，主要区别：

* 输入时 `%d` 读取整数，`%f` 读取浮点数等
* 变量传入地址，如 `&a`

```c
int a;
scanf("%d", &a);
```

---

### 14.4.3 注意事项

* 输入缓冲区不自动清空，可能导致后续输入异常
* `%s` 读取字符串遇空白停止，容易溢出
* 推荐使用宽度限制避免溢出

```c
char str[10];
scanf("%9s", str);
```

---

### 14.4.4 其他输入函数

| 函数          | 说明           |
| ----------- | ------------ |
| `getchar()` | 读取一个字符       |
| `gets()`    | 读取一行字符串（已弃用） |
| `fgets()`   | 读取一行字符串（推荐）  |

---

## 14.5 输入输出缓冲机制

### 14.5.1 缓冲类型

* **行缓冲**（stdout 终端时）
* **全缓冲**（文件流）
* **无缓冲**

---

### 14.5.2 强制刷新缓冲区

```c
fflush(stdout);
```

---

### 14.5.3 标准输入输出缓冲引发的问题

* 输入缓冲区残留内容可能影响后续输入
* 输出缓冲延迟显示（遇换行或缓冲满才刷出）

---

## 14.6 错误处理

* 检查 `scanf()` 返回值，判断是否成功读取
* 输出时检查 `printf()` 返回值（字符数或负值表示错误）
* 文件操作时检查 `fopen()` 返回指针是否为 NULL

---

## 14.7 常见易错点

| 错误              | 说明             | 解决建议                  |
| --------------- | -------------- | --------------------- |
| 输入变量地址忘加 `&`    | 传入值而非地址，导致读取失败 | 输入变量时都要传地址            |
| `%s` 溢出         | 字符串输入超过数组大小    | 使用 `%9s` 限制宽度         |
| 使用已弃用的 `gets()` | 不安全，容易造成缓冲区溢出  | 用 `fgets()` 替代        |
| 输入缓冲区残留         | 多次输入时造成读取异常    | 使用 `getchar()` 清空残留字符 |

---

## 14.8 工程实践建议

✅ 优先使用 `fgets()` 读取字符串，避免溢出
✅ 输入输出格式控制符一定要和变量类型匹配
✅ 输出时注意字段宽度对齐，提高美观度
✅ 输入时检测返回值，防止错误输入导致程序崩溃
✅ 理解缓冲机制，避免交互延迟或异常

---

## 14.9 总结

> * `printf()` 和 `scanf()` 是最常用的格式化输入输出函数
> * `%d`、`%f`、`%s` 是最常用格式符
> * 输入函数参数必须是变量地址
> * 注意缓冲区管理，避免输入输出异常
> * `fgets()` 代替 `gets()` 是安全编程必备

---

# 十五、文件管理（File Management）

## 15.1 文件管理概述

* 文件是存储在磁盘上的数据集合，是程序与外部数据交换的主要方式
* C语言通过 `<stdio.h>` 标准库提供文件操作接口
* 文件操作是面向流（stream）的，文件作为字节流进行读写

---

## 15.2 文件基本概念

| 术语        | 说明             |
| --------- | -------------- |
| 文件流（FILE） | 标准库定义的文件类型结构体  |
| 文件指针      | 指向当前文件操作位置的指针  |
| 文本文件      | 以文本形式存储数据，按行处理 |
| 二进制文件     | 按二进制字节读写，无特殊格式 |

---

## 15.3 文件打开与关闭

### 15.3.1 打开文件：`fopen()`

```c
FILE *fopen(const char *filename, const char *mode);
```

* 返回文件指针 `FILE *`
* `mode` 模式参数：

| 模式                     | 说明                      |
| ---------------------- | ----------------------- |
| `"r"`                  | 以只读方式打开文件（文件必须存在）       |
| `"w"`                  | 以写入方式打开（文件不存在则创建，存在则清空） |
| `"a"`                  | 以追加方式打开（文件不存在则创建）       |
| `"rb"`, `"wb"`, `"ab"` | 以二进制模式打开，行为同上           |

---

### 15.3.2 关闭文件：`fclose()`

```c
int fclose(FILE *stream);
```

* 关闭文件，释放资源
* 返回0表示成功，EOF表示失败

---

## 15.4 文件读写操作

### 15.4.1 读文件

| 函数                                                          | 说明            |
| ----------------------------------------------------------- | ------------- |
| `fgetc(FILE *stream)`                                       | 读取一个字符        |
| `fgets(char *str, int n, FILE *stream)`                     | 读取一行（最多n-1字符） |
| `fread(void *ptr, size_t size, size_t nmemb, FILE *stream)` | 读二进制数据        |

---

### 15.4.2 写文件

| 函数                                                                 | 说明     |
| ------------------------------------------------------------------ | ------ |
| `fputc(int c, FILE *stream)`                                       | 写一个字符  |
| `fputs(const char *str, FILE *stream)`                             | 写字符串   |
| `fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)` | 写二进制数据 |

---

## 15.5 文件定位

| 函数                                             | 说明         |
| ---------------------------------------------- | ---------- |
| `fseek(FILE *stream, long offset, int whence)` | 设置文件指针位置   |
| `ftell(FILE *stream)`                          | 返回当前文件指针位置 |
| `rewind(FILE *stream)`                         | 回到文件开头     |

---

## 15.6 文件错误与状态检测

| 函数                       | 说明           |
| ------------------------ | ------------ |
| `feof(FILE *stream)`     | 判断是否到达文件末尾   |
| `ferror(FILE *stream)`   | 判断文件操作是否发生错误 |
| `clearerr(FILE *stream)` | 清除错误标志       |

---

## 15.7 文件操作示例

```c
FILE *fp = fopen("test.txt", "r");
if (fp == NULL) {
    perror("Failed to open file");
    return -1;
}
char buf[100];
while (fgets(buf, sizeof(buf), fp)) {
    printf("%s", buf);
}
fclose(fp);
```

---

## 15.8 文件模式说明（详细）

| 模式    | 说明                      |
| ----- | ----------------------- |
| `r`   | 只读，文件必须存在               |
| `w`   | 写入，文件不存在则创建，存在则清空       |
| `a`   | 追加，文件不存在则创建，写入内容追加到文件末尾 |
| `r+`  | 读写，文件必须存在               |
| `w+`  | 读写，文件不存在则创建，存在则清空       |
| `a+`  | 读写，文件不存在则创建，写入追加到末尾     |
| 加 `b` | 二进制模式（如 `rb`、`wb`），跨平台用 |

---

## 15.9 文件操作注意事项

* 打开文件后必须关闭，避免资源泄漏
* 操作文件前检查指针是否为 NULL
* 文件读写过程中注意缓冲刷新和错误处理
* 读写二进制数据时要使用对应的函数和模式
* 使用 `perror()` 输出错误信息，方便调试

---

## 15.10 工程实践建议

✅ 文件操作前务必判断是否成功打开
✅ 使用二进制模式读写非文本文件
✅ 写文件操作后调用 `fflush()` 或关闭文件确保数据写入
✅ 读取文本文件建议使用 `fgets()`，避免缓冲区溢出
✅ 代码中尽量封装文件操作，统一错误处理

---

## 15.11 总结

> * 文件管理是 C 程序与外界数据交互的桥梁
> * `fopen()`、`fclose()` 是文件操作起点和终点
> * `fread()`、`fwrite()` 适合二进制操作
> * 文件指针定位函数便于随机访问
> * 养成良好的错误检测习惯，保证程序健壮性

---
