
# 一、什么是ISA
**ISA（Instruction Set Architecture）** 概念是计算机体系结构的核心之一。我们一步步来讲清楚。

---

## 1.1 ISA 的全称与定义

**ISA（Instruction Set Architecture）**，中文叫做 **指令集架构** 或 **指令系统结构**。

它是**硬件与软件之间的接口**，规定了 **CPU能理解和执行的所有指令** 的集合。
👉 换句话说，**ISA定义了“CPU能做什么”以及“程序该怎么告诉CPU去做”**。

---

## 1.2 ISA的主要内容包括

ISA并不仅仅是一组指令，它其实规定了一整套规则，包括：

| 类别          | 内容说明                            |
| ----------- | ------------------------------- |
| **指令系统**    | 包含CPU可执行的所有指令（如加法、减法、加载、跳转、比较等） |
| **寄存器结构**   | 定义了CPU内部有哪些寄存器、每个寄存器的用途和数量      |
| **寻址方式**    | 定义了指令如何访问内存中的数据（立即数、寄存器、间接寻址等）  |
| **数据类型与格式** | 比如整型、浮点型、字符型的编码规则               |
| **中断与异常机制** | 定义CPU如何响应外部中断或异常情况              |
| **存储模型**    | 定义内存地址空间的布局和访问方式                |
| **I/O机制**   | 规定CPU与外设交互的方式                   |

---

## 1.3 ISA与微架构的区别

很多人会混淆 ISA 和 **CPU微架构（Microarchitecture）**，这两个不是一回事：

| 项目   | ISA（指令集架构）     | 微架构（Microarchitecture）            |
| ---- | -------------- | --------------------------------- |
| 定义   | 规定“CPU能理解的语言”  | 规定“CPU内部如何实现这些语言”                 |
| 类似于  | 软件接口规范         | 具体实现方式                            |
| 举例   | x86、ARM、RISC-V | Intel Core i7、Apple M3、Cortex-A78 |
| 是否固定 | 通常固定，由标准定义     | 可变，同一ISA可有多种实现                    |

💡例如：

* Intel的Core i9 和 AMD的Ryzen 都实现了 **x86-64 ISA**；
* 但它们的**内部电路设计完全不同**（也就是微架构不同）。

---

## 1.4 常见的ISA类型

| ISA名称            | 类型          | 代表CPU厂商/平台                   | 特点                   |
| ---------------- | ----------- | ---------------------------- | -------------------- |
| **x86 / x86-64** | CISC（复杂指令集） | Intel, AMD                   | 历史悠久，指令复杂但兼容性好       |
| **ARM**          | RISC（精简指令集） | ARM, Apple M系列, 高通Snapdragon | 功耗低、性能高、移动设备主流       |
| **RISC-V**       | RISC（开放指令集） | 开源架构，众多厂商支持                  | 免费、可扩展、适合教学与研究       |
| **MIPS**         | RISC        | 嵌入式系统                        | 早期广泛使用，但已被RISC-V取代趋势 |
| **PowerPC**      | RISC        | IBM, 任天堂旧主机                  | 曾用于Mac与嵌入式系统         |

---

## 1.5 ISA在系统中的位置

可以这样理解：

```
┌────────────────────────┐
│   应用程序 / 编译器     │
├────────────────────────┤
│   ISA（指令集架构）     │ ← 软件与硬件的接口
├────────────────────────┤
│   微架构（CPU实现）     │
├────────────────────────┤
│   逻辑电路与物理硬件     │
└────────────────────────┘
```

软件通过编译器将代码编译成**ISA指令**（机器码），CPU再根据**微架构**执行这些指令。

---

## 1.6 一个简单例子

比如我们写一段C语言：

```c
a = b + c;
```

编译器会把它转换成 ISA 层的汇编指令（假设是RISC-V）：

```asm
add x1, x2, x3   # x1 = x2 + x3
```

CPU最终根据这个指令完成寄存器运算。
这条 `add` 指令的定义（格式、操作数、功能）——就是由 **RISC-V ISA** 规定的。

---

## 1.7 总结

> **ISA 就是定义 CPU “语言规则”的规范，决定程序如何与硬件交互。**

不同ISA之间的软件通常不兼容（比如x86程序不能直接在ARM芯片上运行），除非通过模拟器或重新编译。

---

# 二、指令集字段结构和宽度
非常棒 👍！
这次我们在前面的结构基础上，**给每种指令集加上直观的实例讲解**（例如具体的机器指令、作用、场景），帮助你更形象地理解这些字段是如何被使用的。

---

## 2.1 常见指令集字段结构 + 应用实例详解

我们从最清晰的 **RISC-V → MIPS → ARM → Power → x86** 讲起。
每种都会包含：

1. **指令结构**
2. **字段说明**
3. **应用举例（含机器码结构）**

---

## 2.2 RISC-V 指令集（RISC风格代表）

### 🔹 典型 R 型（寄存器操作）指令格式

```
| funct7 | rs2 | rs1 | funct3 | rd | opcode |
| 7 bits | 5   | 5   | 3      | 5  | 7 bits |
```

### 🔹 字段解释

| 字段                | 含义    | 举例说明                     |
| ----------------- | ----- | ------------------------ |
| **opcode**        | 操作类型  | `0110011` 表示“寄存器-寄存器运算类” |
| **rd**            | 目标寄存器 | 运算结果保存位置，如 `x5`          |
| **rs1/rs2**       | 源寄存器  | 两个输入操作数                  |
| **funct3/funct7** | 功能码   | 区分不同运算，如 `add` 与 `sub`   |

### 🔹 示例

指令：

```
add x5, x1, x2    # x5 = x1 + x2
```

机器码（32位）：

```
0000000 00010 00001 000 00101 0110011
 funct7  rs2   rs1  funct3 rd   opcode
```

💡 应用场景：
在 CPU 执行 ALU 加法时（例如计算数组索引、循环变量），就会生成这样的 R 型加法指令。

---

## 2.3 MIPS 指令集（RISC-V 的“祖师”）

### 🔹 R 型格式

```
| opcode | rs | rt | rd | shamt | funct |
| 6 bits | 5  | 5  | 5  | 5     | 6 bits |
```

### 🔹 示例

```
add $t0, $t1, $t2   # t0 = t1 + t2
```

机器码：

```
000000 01001 01010 01000 00000 100000
opcode  rs    rt    rd    shamt funct
```

| 字段            | 含义         |
| ------------- | ---------- |
| opcode=000000 | 表示 R 型算术指令 |
| funct=100000  | 表示 ADD 操作  |
| rs, rt, rd    | 分别是源和目标寄存器 |

💡 应用场景：
大学计算机组成课程和单周期CPU实验常用 MIPS，逻辑清晰，译码容易。

---

## 2.4 ARMv8 (AArch64)

### 🔹 寄存器操作格式（ADD 类）

```
| opcode | Rm | shamt | Rn | Rd |
| 11 bits | 5 bits | 6 bits | 5 bits | 5 bits |
```

### 🔹 示例

```
ADD X0, X1, X2   // X0 = X1 + X2
```

机器码（二进制结构化）：

```
10001011000 00010 000000 00001 00000
  opcode    Rm     shamt   Rn     Rd
```

| 字段     | 含义            |
| ------ | ------------- |
| opcode | 表示这是 64位寄存器加法 |
| Rn     | 第一个源寄存器       |
| Rm     | 第二个源寄存器       |
| Rd     | 目标寄存器         |

💡 应用场景：
ARM 在手机处理器（如 Apple M 系列、Snapdragon）中，执行每一条算术指令（加、减、逻辑运算）都用这种结构。
例如应用程序计算图片像素、音频滤波、向量加法时都会大量触发这种指令。

---

## 2.5 Power ISA（IBM PowerPC）

### 🔹 格式

```
| opcode | rs | ra | rb | xo | rc |
| 6 bits | 5  | 5  | 5  | 10 | 1  |
```

### 🔹 示例

```
add r3, r4, r5   # r3 = r4 + r5
```

机器码：

```
011111 00100 00011 00101 01010 0
 opcode  rs     ra     rb    xo  rc
```

| 字段     | 含义                   |
| ------ | -------------------- |
| opcode | 操作类别                 |
| xo     | “扩展操作码”，区分 add/sub 等 |
| rc     | 是否更新条件标志寄存器          |

💡 应用场景：
Power 架构多用于 **高可靠服务器** 与 **超级计算机**，例如 IBM Power9、Power10。
执行高性能矩阵运算（如 AI 训练或金融风险模拟）时会用到类似的定长指令。

---

## 2.6 x86 / x86-64（CISC风格）

x86 不像 RISC 一样规则，它是**可变长度指令（1～15 字节）**。
基本格式如下：

```
| Prefix | Opcode | ModR/M | SIB | Displacement | Immediate |
```

### 🔹 示例

```
add rax, rbx    ; 64位加法
```

机器码（x86-64）：

```
48 01 D8
```

拆解说明：

| 字节 | 含义                     |
| -- | ---------------------- |
| 48 | REX前缀：使用64位寄存器         |
| 01 | opcode（ADD）            |
| D8 | ModR/M 字节，指明 rax 与 rbx |

ModR/M 结构：

```
| mod | reg | r/m |
| 11  | 011 | 000 |
```

表示：

* mod=11（二进制） → 寄存器对寄存器操作
* reg=011 → rbx
* r/m=000 → rax

💡 应用场景：
x86 广泛用于 **Windows/Linux PC**、**数据中心服务器**。
如编译器在处理：

```c
sum = a + b;
```

时，最终生成的机器码就类似于这种 `add rax, rbx`。

---

## 2.6 不同架构的结构与实例对比

| ISA          | 指令长度  | 字段示例                                              | 应用例子              | 特点        |
| ------------ | ----- | ------------------------------------------------- | ----------------- | --------- |
| **RISC-V**   | 32位固定 | opcode(7)+rd(5)+funct3(3)+rs1(5)+rs2(5)+funct7(7) | `add x5,x1,x2`    | 开源灵活，科研常用 |
| **MIPS**     | 32位固定 | opcode(6)+rs(5)+rt(5)+rd(5)+shamt(5)+funct(6)     | `add $t0,$t1,$t2` | 教学/嵌入式    |
| **ARMv8**    | 32位固定 | opcode(11)+Rm(5)+Rn(5)+Rd(5)+shamt(6)             | `ADD X0,X1,X2`    | 手机/笔电     |
| **PowerISA** | 32位固定 | opcode(6)+ra(5)+rb(5)+rs(5)+xo(10)+rc(1)          | `add r3,r4,r5`    | 超算/工业控制   |
| **x86-64**   | 可变长度  | Prefix+Opcode+ModR/M(+SIB)                        | `add rax,rbx`     | PC/服务器    |

---

## 2.7 总结

> 🧠 **RISC 指令像“模板”，每条长度一样，易译码**
> 💻 **x86 指令像“语言”，灵活但复杂，译码成本高**

| 架构         | 设计哲学       | 应用          |
| ---------- | ---------- | ----------- |
| **RISC-V** | 简洁统一、模块化   | 教学、AI、自主CPU |
| **MIPS**   | 规则化、教学友好   | 嵌入式/课程设计    |
| **ARM**    | 功耗低、高集成度   | 移动端、笔电、服务器  |
| **Power**  | 并行与可靠性强    | 超算、银行、工业    |
| **x86**    | 兼容性优先、功能全面 | PC、数据中心     |


---

# 三、 RISC-V指令集

## 3.1 RISC-V 指令集的指令长度设计

RISC-V 的设计目标之一是**简单、规则、便于解码**，因此它采用了一个非常巧妙的方案：

> ✅ **RISC-V 的基本指令长度是 32 位（4 字节）**，
> 但为了兼顾**压缩与扩展**，它同时支持 **16 位、32 位、48 位、64 位甚至更长** 的“可变长度指令格式”。

---

## 3.2 核心结构：定长 + 可变长结合

| 类别                   | 指令长度             | 说明                                         |
| -------------------- | ---------------- | ------------------------------------------ |
| **标准基础指令（Base ISA）** | **32位**          | RV32I / RV64I / RV128I 的核心指令长度固定为32位。      |
| **压缩指令集（C扩展）**       | **16位**          | RV32IC / RV64IC 中的“Compressed ISA”，节省代码空间。 |
| **可扩展长指令（扩展空间）**     | **48位、64位、>64位** | 为将来复杂扩展（如V向量、B位操作）预留空间。                    |

---

## 3.3 示例说明

### 1️⃣ 标准32位指令示例

```asm
add x3, x1, x2
```

对应的机器码（RV32I）：

```
0000000 00010 00001 000 00011 0110011
```

总计 32 位（每段有固定含义）：

* opcode: 7 位
* rd: 5 位
* funct3: 3 位
* rs1: 5 位
* rs2: 5 位
* funct7: 7 位

---

### 2️⃣ 压缩指令（16位）

开启 **C 扩展** 后，某些常用指令可以使用更短的编码形式：

```asm
c.addi x1, 5
```

机器码只有 **16 位**，节省程序存储空间达 25%~30%。

📘 适用于嵌入式或存储空间有限的系统。

---

### 3️⃣ 向量指令（V扩展）

在高性能计算（HPC、AI）中，RISC-V 的 **V扩展（Vector Extension）** 支持更长的操作码，例如 48 位 或更长，用于编码更复杂的向量操作。

---

## 3.4 总结表格

| 类型                | 名称                     | 指令长度    | 典型用途      |
| ----------------- | ---------------------- | ------- | --------- |
| RV32I / RV64I 基础集 | Base Integer           | **32位** | 所有实现必须支持  |
| C 扩展              | Compressed             | **16位** | 提高代码密度    |
| V 扩展              | Vector                 | 48位或更长  | 高性能运算     |
| 未来保留              | Reserved for expansion | ≥64位    | 为未来复杂指令保留 |

---

## 3.5 总结

> 🧠 **RISC-V 的核心指令是 32 位定长格式，
> 但体系允许 16 位、48 位、64 位及更长的扩展指令，实现“可变长度指令架构”。**

---

# 四、RISC-V基础指令集-RV32I

## 4.1 RISC-V 指令集总体结构

RISC-V 是一种 **模块化（modular）指令集架构**，由一个最小的“基础指令集”（Base ISA）和若干个可选扩展（Extensions）组成。
基础集是所有处理器都必须支持的，而扩展集是根据场景（嵌入式、AI、GPU、通用 CPU）选配的。

---

### 基础指令集：`RV32I` / `RV64I` / `RV128I`

| 类型         | 含义             | 位宽             | 典型应用        |
| ---------- | -------------- | -------------- | ----------- |
| **RV32I**  | 基础 32 位整数指令集   | 32 位寄存器、32 位地址 | 嵌入式系统、MCU   |
| **RV64I**  | 基础 64 位整数指令集   | 64 位寄存器、64 位地址 | 通用 CPU、服务器  |
| **RV128I** | 128 位指令集（实验阶段） | 128 位寄存器       | 超高性能计算（HPC） |

---

## 4.2 RISC-V 的指令格式（Instruction Formats）

RISC-V 基础集主要有六种格式，每种格式的字段排列不同：

| 格式         | 典型用途              | 结构字段                                       |                              |             |                   |
| ---------- | ----------------- | ------------------------------------------ | ---------------------------- | ----------- | ----------------- |
| **R-type** | 寄存器间运算            | `funct7 rs2 rs1 funct3 rd opcode`          |                              |             |                   |
| **I-type** | 立即数运算 / 加载        | `imm[11:0] rs1 funct3 rd opcode`           |                              |             |                   |
| **S-type** | 存储指令（Store）       | `imm[11:5] rs2 rs1 funct3 imm[4:0] opcode` |                              |             |                   |
| **B-type** | 分支（Branch）        | `imm[12                                    | 10:5] rs2 rs1 funct3 imm[4:1 | 11] opcode` |                   |
| **U-type** | 高位立即数（LUI, AUIPC） | `imm[31:12] rd opcode`                     |                              |             |                   |
| **J-type** | 跳转（JAL）           | `imm[20                                    | 10:1                         | 11          | 19:12] rd opcode` |

```
注：指令格式对基础指令集和拓展指令集都通用
```

---

## 4.3 R-type：寄存器运算指令（Register）

### ✅ 例子：`add x5, x6, x7`

表示：`x5 = x6 + x7`

| 字段     | 位数 | 含义                                  |
| ------ | -- | ----------------------------------- |
| opcode | 7  | `0110011` → R-type                  |
| funct3 | 3  | `000` 表示加法                          |
| funct7 | 7  | `0000000` 表示普通加法（若为 `0100000` 则是减法） |
| rs1    | 5  | 源寄存器 1（x6）                          |
| rs2    | 5  | 源寄存器 2（x7）                          |
| rd     | 5  | 目的寄存器（x5）                           |

🧠 **执行逻辑**：
取出寄存器 x6 和 x7 的值，相加后写入 x5。
在硬件上，这是一条**ALU算术操作指令**。

---

## 4.4 I-type：立即数指令与加载指令（Immediate）

### ✅ 例子 1：`addi x5, x6, 10`

表示：`x5 = x6 + 10`

| 字段        | 位数 | 含义        |
| --------- | -- | --------- |
| opcode    | 7  | `0010011` |
| funct3    | 3  | `000`（加法） |
| imm[11:0] | 12 | 立即数 `10`  |
| rs1       | 5  | 源寄存器 x6   |
| rd        | 5  | 目的寄存器 x5  |

🧠 **执行逻辑**：
ALU 从寄存器 x6 取值，加上立即数 10，结果写回 x5。
这种设计避免了必须再加载常数的额外内存访问，提高了效率。

---

### ✅ 例子 2：`lw x5, 8(x6)`

表示：从内存地址 `x6 + 8` 读取 4 字节数据到寄存器 x5。

| 字段     | 含义         |
| ------ | ---------- |
| opcode | `0000011`  |
| funct3 | `010`（字加载） |
| imm    | 偏移量 8      |
| rs1    | 基址寄存器 x6   |
| rd     | 目的寄存器 x5   |

---

## 4.5 S-type：存储指令（Store）

### ✅ 例子：`sw x5, 12(x6)`

表示：将寄存器 x5 的值存入内存地址 `x6 + 12`

| 字段     | 含义               |
| ------ | ---------------- |
| opcode | `0100011`        |
| funct3 | `010`（存字）        |
| rs1    | 基址寄存器            |
| rs2    | 要存的寄存器           |
| imm    | 立即数分两部分存放（高位+低位） |

🧠 执行逻辑：
ALU 计算 `x6 + 12`，然后把寄存器 x5 的数据写入该内存地址。

---

## 4.6 B-type：条件分支指令（Branch）

### ✅ 例子：`beq x1, x2, label`

表示：若 `x1 == x2`，则跳转到 label。

| 字段       | 含义           |
| -------- | ------------ |
| opcode   | `1100011`    |
| funct3   | `000`（表示BEQ） |
| rs1, rs2 | 比较的寄存器       |
| imm      | 分支偏移量        |

🧠 硬件行为：
比较寄存器值 → 若相等 → PC ← PC + 偏移量。

---

## 4.7 U-type：高位立即数操作（Upper）

### ✅ 例子：`lui x10, 0x12345`

表示：将立即数 `0x12345 << 12` 加载到寄存器 x10 高位。

| 字段         | 含义        |
| ---------- | --------- |
| opcode     | `0110111` |
| imm[31:12] | 立即数高位部分   |
| rd         | 目的寄存器     |

🧠 常用于生成大常数或高地址。

---

## 4.8 J-type：跳转指令（Jump）

### ✅ 例子：`jal x1, 256`

表示：跳转到 `PC + 256`，并将返回地址写入 x1（类似函数调用）。

| 字段     | 含义         |
| ------ | ---------- |
| opcode | `1101111`  |
| imm    | 跳转偏移量      |
| rd     | 保存返回地址的寄存器 |

---

## 4.9 总结对比（例子汇总）

| 指令类型   | 示例                | 功能        | 字段分布                                     |                              |            |                  |
| ------ | ----------------- | --------- | ---------------------------------------- | ---------------------------- | ---------- | ---------------- |
| R-type | `add x5, x6, x7`  | 寄存器 + 寄存器 | funct7 rs2 rs1 funct3 rd opcode          |                              |            |                  |
| I-type | `addi x5, x6, 10` | 寄存器 + 立即数 | imm[11:0] rs1 funct3 rd opcode           |                              |            |                  |
| S-type | `sw x5, 12(x6)`   | 存储到内存     | imm[11:5] rs2 rs1 funct3 imm[4:0] opcode |                              |            |                  |
| B-type | `beq x1, x2, L`   | 条件跳转      | imm[12                                   | 10:5] rs2 rs1 funct3 imm[4:1 | 11] opcode |                  |
| U-type | `lui x10, imm`    | 装载高位立即数   | imm[31:12] rd opcode                     |                              |            |                  |
| J-type | `jal x1, offset`  | 跳转与链接     | imm[20                                   | 10:1                         | 11         | 19:12] rd opcode |

---

# 五、RISC-V扩展指令集-（M：乘法）

## 5.1 M 扩展简介

RISC-V 是一个**模块化设计**的指令集架构（ISA），它的基本版本叫：

> **RV32I / RV64I / RV128I**
> （I 表示 "Integer" 基础指令集）

在此基础上，RISC-V 允许添加扩展来增强功能，比如：

| 扩展名 | 含义                              | 功能           |
| :-- | :------------------------------ | :----------- |
| M   | Multiply / Divide               | 整数乘除运算       |
| A   | Atomic                          | 原子操作         |
| F   | Single-Precision Floating Point | 单精度浮点        |
| D   | Double-Precision Floating Point | 双精度浮点        |
| C   | Compressed                      | 指令压缩（16 位指令） |
| ... | ...                             | ...          |

➡️ 所以 “RV32IM” 就表示：
这是一个 **32 位** 架构，支持 **整数 + 乘除法扩展**。

---

## 5.2 M 扩展的功能

M 扩展主要增加了 **8 条指令**，用于：

* **乘法（Multiply）**
* **除法（Divide）**
* **取余（Remainder）**

这些指令适用于有符号和无符号整数。

---

## 5.3 M 扩展指令表

| 指令       | 含义                    | 功能描述                                |
| :------- | :-------------------- | :---------------------------------- |
| `MUL`    | 有符号乘法                 | `rd = (rs1 * rs2)[31:0]` 取低 32 位结果  |
| `MULH`   | 高位乘法（两个有符号数）          | `rd = (rs1 * rs2)[63:32]` 取高 32 位结果 |
| `MULHSU` | 高位乘法（rs1 有符号，rs2 无符号） | 同上，混合乘法                             |
| `MULHU`  | 高位乘法（两个无符号数）          | 同上，纯无符号                             |
| `DIV`    | 有符号除法                 | `rd = rs1 / rs2`                    |
| `DIVU`   | 无符号除法                 | `rd = rs1 / rs2`（无符号）               |
| `REM`    | 有符号取余                 | `rd = rs1 % rs2`                    |
| `REMU`   | 无符号取余                 | `rd = rs1 % rs2`（无符号）               |

---

## 5.4 这些指令的详细行为

### 1️⃣ 乘法类

* **`MUL`**：只保留低位部分（结果截断到寄存器宽度）
* **`MULH` / `MULHSU` / `MULHU`**：保留乘法结果的高位部分
  例如在 RV32 中：

  * 全乘积是 64 位
  * 取高 32 位写入 `rd`

👉 这些指令在**大整数计算**或**高精度乘法**中非常常见（如实现 64 位乘法）。

---

### 2️⃣ 除法类

* **`DIV`**：有符号除法
* **`DIVU`**：无符号除法

特殊情况处理规则：

| 条件                   | 结果                        |
| :------------------- | :------------------------ |
| 除数 = 0               | 结果 = -1（对于有符号）或全 1（对于无符号） |
| rs1 = 最小负数, rs2 = -1 | 结果 = 最小负数（防止溢出）           |

例如在 32 位中：
`rs1 = 0x80000000`, `rs2 = -1`
结果仍为 `0x80000000`

---

### 3️⃣ 取余类

* **`REM`**：有符号取余
* **`REMU`**：无符号取余

规则：

| 条件                   | 结果       |
| :------------------- | :------- |
| 除数 = 0               | 结果 = 被除数 |
| rs1 = 最小负数, rs2 = -1 | 结果 = 0   |

---

## 5.5 编码格式（R-type）

所有 M 扩展指令都是 **R 型指令（R-type）**：

| 字段     | 位宽 | 含义            |
| :----- | :- | :------------ |
| funct7 | 7  | 决定是哪个 M 扩展指令  |
| rs2    | 5  | 第二源寄存器        |
| rs1    | 5  | 第一源寄存器        |
| funct3 | 3  | 决定子类型         |
| rd     | 5  | 目的寄存器         |
| opcode | 7  | 固定为 `0110011` |

---

## 5.6 RISC-V M 扩展编码示例

| 指令       | funct7  | funct3 | opcode  |
| :------- | :------ | :----- | :------ |
| `MUL`    | 0000001 | 000    | 0110011 |
| `MULH`   | 0000001 | 001    | 0110011 |
| `MULHSU` | 0000001 | 010    | 0110011 |
| `MULHU`  | 0000001 | 011    | 0110011 |
| `DIV`    | 0000001 | 100    | 0110011 |
| `DIVU`   | 0000001 | 101    | 0110011 |
| `REM`    | 0000001 | 110    | 0110011 |
| `REMU`   | 0000001 | 111    | 0110011 |

---

## 5.7 示例代码

### 示例 1：乘法

```asm
# 假设 x5 = 6, x6 = 7
mul x7, x5, x6   # x7 = 42
```

### 示例 2：有符号除法

```asm
# x5 = -15, x6 = 4
div x7, x5, x6   # x7 = -3
rem x8, x5, x6   # x8 = -3  (因为 -15 = (-3)*4 + (-3))
```

### 示例 3：无符号除法

```asm
# x5 = 15, x6 = 4
divu x7, x5, x6  # x7 = 3
remu x8, x5, x6  # x8 = 3
```

---

## 5.8 硬件实现简要说明

在硬件层面，M 扩展通常：

* 使用**乘法器模块**（可能为 Booth 乘法或移位加法）
* 使用**除法器模块**（可为恢复式、非恢复式、SRT 或牛顿迭代法）
* 对结果进行**有符号/无符号控制**
* 乘法高低位通过内部乘积 64 位寄存器实现截取

---

## 5.9 总结

| 分类   | 指令                          | 功能简述                           |
| :--- | :-------------------------- | :----------------------------- |
| 乘法   | MUL / MULH / MULHSU / MULHU | 支持有符号与无符号乘法                    |
| 除法   | DIV / DIVU                  | 支持有符号与无符号除法                    |
| 取余   | REM / REMU                  | 计算余数（有符号/无符号）                  |
| 编码类型 | R-type                      | funct7=0000001, opcode=0110011 |

---

# 六、RISC-V扩展指令集-（A：原子）

## 6.1 A 扩展简介

**A = Atomic（原子操作）**

A 扩展为 RISC-V 增加了一组**保证读-改-写操作原子性**的指令，
用于实现：

* 自旋锁（spinlock）
* 互斥量（mutex）
* 信号量（semaphore）
* Compare-and-Swap（CAS）
* 原子加减计数器（atomic increment/decrement）等。

> ⚙️ 没有 A 扩展的指令集，就无法安全地在多核或多线程环境中实现同步原语。

---

## 6.2 为什么要有 A 扩展（动机）

在多核系统中，如果两个核同时访问同一内存地址：

```asm
lw x5, (addr)
addi x5, x5, 1
sw x5, (addr)
```

这段代码逻辑上想做“加 1”，但在两个核心同时执行时可能发生竞争（race condition）：

* 两个核几乎同时读出相同值；
* 各自 +1；
* 最终写回的结果只增加 1，而不是 2。

这就是典型的“非原子性”问题。

为此，RISC-V A 扩展提供了**硬件级锁机制**，确保操作在总线上是原子的。

---

## 6.3 A 扩展提供的两大类指令

A 扩展提供了两类原子操作机制：

| 类别  | 名称                                           | 作用                                 |
| :-- | :------------------------------------------- | :--------------------------------- |
| 1️⃣ | **LR/SC（Load-Reserved / Store-Conditional）** | 通过“预留 + 条件存储”实现可组合的原子操作            |
| 2️⃣ | **AMO（Atomic Memory Operation）**             | 直接执行特定类型的原子读-改-写操作（如 add、and、swap） |

---

## 6.4 LR/SC 机制详解（核心机制）

### 1️⃣ LR/SC 基本原理

* **LR.W（Load Reserved Word）**
  从内存读取一个字（word），并标记该地址为“保留（reserved）”。

* **SC.W（Store Conditional Word）**
  只有当该地址自上次 LR.W 后未被其他核写入过时，才执行写入；
  否则写入失败（返回非零值）。

### 2️⃣ 指令格式

| 指令                    | 格式     | 功能                                              |
| :-------------------- | :----- | :---------------------------------------------- |
| `LR.W rd, (rs1)`      | R-type | 从内存 [rs1] 读 word → rd，并在本核标记为 reserved          |
| `SC.W rd, rs2, (rs1)` | R-type | 若 reserved 地址仍有效，则写 rs2 → [rs1]，rd=0；否则失败，rd=非0 |

在 64 位系统中对应 `LR.D` / `SC.D`（D = double word）。

---

### 3️⃣ 示例：用 LR/SC 实现原子加法

```
asm

# 原子地将内存中的变量加 1
# a0 = 地址
again:
    lr.w  t0, (a0)        # 读取当前值，并设置保留
    addi  t1, t0, 1       # 加 1
    sc.w  t2, t1, (a0)    # 条件写入，t2=0 表示成功
    bnez  t2, again       # 如果失败，重试
```

> ✅ 当多个核竞争同一地址时，只有一个 SC 能成功，其余核的 SC 将失败并自动重试，从而确保原子性。

---

## 6.5 AMO 指令（Atomic Memory Operation）

A 扩展还提供了一组直接的原子操作指令（AMO），
它们自动完成**读、运算、写**，无需使用 LR/SC。

---

### 1️⃣ 指令格式

AMO 指令为 R-type，opcode 固定为 `0101111`。
主要字段：

| 字段        | 含义                       |
| :-------- | :----------------------- |
| funct7    | 决定操作类型（AMOADD、AMOSWAP 等） |
| aq / rl 位 | memory ordering（内存序）控制   |
| rs1       | 内存地址                     |
| rs2       | 操作数                      |
| rd        | 返回旧值                     |

---

### 2️⃣ 支持的 AMO 指令

| 指令            | 功能描述                          | 备注       |
| :------------ | :---------------------------- | :------- |
| **AMOSWAP.W** | 交换：返回旧值，并写入新值                 | 实现自旋锁最常用 |
| **AMOADD.W**  | 加法：`[rs1] = [rs1] + rs2`，返回旧值 | 实现计数器    |
| **AMOXOR.W**  | 按位异或                          |          |
| **AMOAND.W**  | 按位与                           |          |
| **AMOOR.W**   | 按位或                           |          |
| **AMOMIN.W**  | 最小值（有符号）                      |          |
| **AMOMAX.W**  | 最大值（有符号）                      |          |
| **AMOMINU.W** | 最小值（无符号）                      |          |
| **AMOMAXU.W** | 最大值（无符号）                      |          |

在 64 位架构中对应 `.D` 后缀（操作 64 位数据）。

---

### 3️⃣ 示例：使用 AMO 实现自旋锁

```asm
# x0 = 0, x1 = 1, a0 = lock_addr

lock:
    amoswap.w.aq t0, x1, (a0)   # 尝试获取锁（交换）
    bnez t0, lock               # 如果旧值非 0，锁被占用，重试

unlock:
    amoswap.w.rl x0, x0, (a0)   # 释放锁，写回 0
```

> `.aq` 和 `.rl` 是 **Acquire/Release** 位，用于控制内存屏障（memory fence）。

---

## 6.6 A 扩展的同步机制和内存模型

| 标志位             | 全称                | 含义                   |
| :-------------- | :---------------- | :------------------- |
| **aq（Acquire）** | Acquire semantics | 在此之前的内存访问不会被重排到此指令之后 |
| **rl（Release）** | Release semantics | 此指令不会被重排到之后的内存访问之前   |
| **aqrl（都置 1）**  | Full fence        | 完全屏障，最严格同步           |

> 这两个位提供了比单纯 `fence` 更细粒度的内存同步控制。

---

## 6.7 A 扩展编码细节（重要）

所有 A 扩展指令的 **opcode = `0101111`**
（这点和 M 扩展的 `0110011` 不同）。

### LR/SC 编码

| 指令     | funct7        | funct5 | funct3 | opcode  |
| :----- | :------------ | :----- | :----- | :------ |
| `LR.W` | 00010 (aq/rl) | 00000  | 010    | 0101111 |
| `SC.W` | 00011 (aq/rl) | rs2    | 010    | 0101111 |

### AMO 编码举例

| 指令          | funct7        | funct3 | opcode  |
| :---------- | :------------ | :----- | :------ |
| `AMOADD.W`  | 00000 (aq/rl) | 010    | 0101111 |
| `AMOSWAP.W` | 00001 (aq/rl) | 010    | 0101111 |
| `AMOXOR.W`  | 00100 (aq/rl) | 010    | 0101111 |
| `AMOAND.W`  | 01100 (aq/rl) | 010    | 0101111 |
| ...         | ...           | ...    | ...     |

---

## 6.8 硬件实现要点（你若学体系结构，这很关键）

硬件在实现 A 扩展时需要：

1. **支持总线锁或缓存一致性协议（如 MESI）**，确保原子访问。
2. **LR 设置“保留标志（reservation set）”**；
   当检测到其他核写入该地址时，保留失效。
3. **SC 检查该标志是否仍有效**，有效则成功写入并清除标志。
4. **AMO 指令** 直接执行原子读改写逻辑，保证单周期或总线原子性。

---

## 6.9 总结表

| 分类             | 指令                                  | 功能简述                 | 说明             |
| :------------- | :---------------------------------- | :------------------- | :------------- |
| **基本原子对**      | LR.W / SC.W                         | “保留 + 条件写”机制         | 可构建任意原子操作      |
| **原子加法**       | AMOADD.W                            | 加法并返回旧值              | 用于计数器          |
| **原子交换**       | AMOSWAP.W                           | 交换寄存器与内存             | 实现锁            |
| **逻辑运算**       | AMOAND / AMOOR / AMOXOR             | 位操作                  | 位标志更新          |
| **比较选择**       | AMOMIN / AMOMAX / AMOMINU / AMOMAXU | 最值操作                 | 信号量或队列优先级      |
| **支持 32/64 位** | .W / .D                             | 支持字或双字操作             | RV32 / RV64 版本 |
| **内存顺序控制**     | aq / rl 位                           | Acquire / Release 语义 | 防止乱序访问         |

---

## 6.10 A 扩展的地位

| 扩展    | 主要作用 | 是否操作系统必须    |
| :---- | :--- | :---------- |
| M     | 乘除法  | 否（可选）       |
| A     | 原子操作 | ✅ 是（操作系统必需） |
| F / D | 浮点   | 可选          |
| C     | 压缩指令 | 可选          |
| V     | 向量   | 可选          |

> 📌 任何要运行 Linux 或多核操作系统的 RISC-V CPU **都必须实现 A 扩展**。
> 因为内核中的自旋锁、信号量、原子计数都依赖它。

---

## 6.11 总结

> 🔹 **A 扩展 = 硬件级原子操作机制**
> 🔹 提供两种原子方案：
>   LR/SC（灵活构造原子操作）
>   AMO（内置常用原子指令）
> 🔹 操作系统同步的硬件基础。
> 🔹 opcode 固定为 `0101111`。
> 🔹 所有多核 RISC-V 系统必备。

---

# 七、RISC-V扩展指令集-（F：单精度浮点数）

## 7.1 F 扩展简介

* **F = Single-Precision Floating-Point Extension**
* 定义于 RISC-V 特权架构规范的 “RVA22U64 / RVA32U64” 中。
* 遵循标准：**IEEE-754 2008 单精度浮点标准**。

> ⚙️ 它为 RISC-V 增加了一整套专用的浮点寄存器（`f0`~`f31`）
> 并引入了对应的计算、加载、存储与类型转换指令。

---

## 7.2 浮点数表示格式（IEEE-754 单精度）

单精度浮点数（`float`）32 位结构如下：

| 字段                  | 位宽 | 含义           |
| :------------------ | :- | :----------- |
| Sign                | 1  | 符号位（0=正，1=负） |
| Exponent            | 8  | 指数位（偏移量 127） |
| Fraction (Mantissa) | 23 | 尾数（隐含最高位 1）  |

计算公式：
$$
value = (-1)^{Sign} \times (1.\text{Fraction}) \times 2^{(Exponent - 127)}
$$

---

## 7.3 F 扩展的主要组成部分

F 扩展主要包括三类指令：

| 类别             | 功能             | 示例                                                           |
| :------------- | :------------- | :----------------------------------------------------------- |
| **浮点算术运算**  | 加减乘除、平方根、符号操作等 | `fadd.s`, `fsub.s`, `fmul.s`, `fdiv.s`, `fsqrt.s`, `fsgnj.s` |
| **类型转换**    | 浮点 ↔ 整数 之间互转   | `fcvt.w.s`, `fcvt.s.w`, `fcvt.l.s`, `fcvt.s.lu`              |
| **加载 / 存储** | 内存与浮点寄存器间传输    | `flw`, `fsw`                                                 |


> 另外还引入了一些状态寄存器（CSR）来控制浮点操作的行为。

---

## 7.4 浮点寄存器集 (FPRs)

F 扩展引入了 **32 个 32 位浮点寄存器**：

| 名称                          | 位宽     | 说明       |
| :-------------------------- | :----- | :------- |
| `f0` ~ `f31`                | 32-bit | 单精度浮点寄存器 |
| `f0` 也可作为返回寄存器（与 x10/a0 类似） |        |          |

> 在 RV64 系统中，这些寄存器的物理宽度为 64 位，低 32 位用于单精度操作，高位清零。

---

## 7.5 CSR 寄存器（浮点状态控制）

F 扩展引入三个控制寄存器：

| CSR 名称     | 地址    | 功能                     |
| :--------- | :---- | :--------------------- |
| **fflags** | 0x001 | 浮点异常标志寄存器              |
| **frm**    | 0x002 | 浮点舍入模式寄存器              |
| **fcsr**   | 0x003 | 复合寄存器（包含 fflags 与 frm） |

---

### 1️⃣ `fflags` — 浮点异常标志位

| 位  | 名称 | 说明          |
| :- | :- | :---------- |
| 4  | NV | 无效操作（如 0/0） |
| 3  | DZ | 除以零         |
| 2  | OF | 溢出          |
| 1  | UF | 下溢          |
| 0  | NX | 非精确（舍入误差）   |

> 这些标志会在每次浮点运算后由硬件自动设置。

---

### 2️⃣ `frm` — 舍入模式寄存器

| 值   | 模式  | 含义                                       |
| :-- | :-- | :--------------------------------------- |
| 000 | RNE | 取最近偶数（Round to Nearest, ties to Even）✅默认 |
| 001 | RTZ | 向 0 舍入                                   |
| 010 | RDN | 向负无穷舍入                                   |
| 011 | RUP | 向正无穷舍入                                   |
| 100 | RMM | 向最近，ties to Max Magnitude                |
| 111 | DYN | 动态舍入（由指令控制）                              |

---

### 3️⃣ `fcsr` = `frm` × 3 bits + `fflags` × 5 bits

可用单指令访问：

```asm
csrr  t0, fcsr     # 读取
csrw  fcsr, t0     # 写入
```

---

## 7.6 F 扩展的主要指令集

下面我们分大类看指令👇

---

### ① 加减乘除与平方根

| 指令                    | 功能      | 示例                  |
| :-------------------- | :------ | :------------------ |
| `fadd.s rd, rs1, rs2` | 单精度浮点加法 | `fadd.s f3, f1, f2` |
| `fsub.s rd, rs1, rs2` | 减法      | `fsub.s f3, f1, f2` |
| `fmul.s rd, rs1, rs2` | 乘法      | `fmul.s f3, f1, f2` |
| `fdiv.s rd, rs1, rs2` | 除法      | `fdiv.s f3, f1, f2` |
| `fsqrt.s rd, rs1`     | 平方根     | `fsqrt.s f3, f1`    |

> 默认使用当前 `frm`（舍入模式）。

---

### ② 比较与符号操作

| 指令                   | 功能                 | 结果存入整数寄存器 |
| :------------------- | :----------------- | :-------- |
| `feq.s rd, rs1, rs2` | 若相等则 rd=1，否则 0     |           |
| `flt.s rd, rs1, rs2` | 若 rs1 < rs2 则 rd=1 |           |
| `fle.s rd, rs1, rs2` | 若 rs1 ≤ rs2 则 rd=1 |           |

符号与绝对值操作：

| 指令                     | 功能                     |
| :--------------------- | :--------------------- |
| `fsgnj.s rd, rs1, rs2` | 将 rs1 的数值部分与 rs2 的符号组合 |
| `fsgnjn.s`             | 符号取反                   |
| `fsgnjx.s`             | 符号异或（改变正负号）            |
| `fabs.s`               | 绝对值                    |
| `fneg.s`               | 取负                     |

---

### ③ 整数 ↔ 浮点 转换

| 指令                  | 功能                |
| :------------------ | :---------------- |
| `fcvt.w.s rd, rs1`  | 浮点 → 有符号整型（32 位）  |
| `fcvt.wu.s rd, rs1` | 浮点 → 无符号整型        |
| `fcvt.s.w rd, rs1`  | 有符号整型 → 浮点        |
| `fcvt.s.wu rd, rs1` | 无符号整型 → 浮点        |
| `fmv.x.w rd, rs1`   | 按位移动（float → int） |
| `fmv.w.x rd, rs1`   | 按位移动（int → float） |

> ⚠️ 转换与“按位复制”不同，`fcvt` 会数值转换，`fmv` 是 bit-level move。

---

### ④ 加载 / 存储指令

| 指令                     | 功能                | 示例 |
| :--------------------- | :---------------- | :- |
| `flw rd, offset(rs1)`  | 从内存加载单精度浮点数到 `rd` |    |
| `fsw rs2, offset(rs1)` | 将 `rs2` 中的浮点数存入内存 |    |

> 对应的 opcode 不同于整数型的 `lw` / `sw`。

---

## 7.7 浮点运算单元（FPU）架构关系

硬件中，F 扩展增加一个 **FPU (Floating Point Unit)**：

```
┌──────────────────────────┐
│ 整数寄存器堆 (x0–x31)     │
└────────────┬─────────────┘
             │
      ┌──────▼──────┐
      │ 浮点寄存器堆 (f0–f31) │
      └──────┬──────┘
             │
      ┌──────▼──────────┐
      │ 浮点算术单元 FPU │
      │ (add, mul, div, √, cmp) │
      └─────────────────────────┘
```

它与整数流水线独立，可以并行执行，从而提高性能。

---

## 7.8 F 扩展的编码结构（R-type/I-type）

### 算术类（R-type）

| 字段     | 含义                           |
| :----- | :--------------------------- |
| funct7 | 运算类型（如 add/sub/mul/div/sqrt） |
| rs2    | 第二浮点源寄存器                     |
| rs1    | 第一浮点源寄存器                     |
| funct3 | 指定精度（`001` → .S）             |
| rd     | 目标浮点寄存器                      |
| opcode | 固定为 `1010011`                |

---

### 加载 / 存储（I-type / S-type）

| 指令    | opcode  |
| :---- | :------ |
| `flw` | 0000111 |
| `fsw` | 0100111 |

---

## 7.9 F 扩展与 D 扩展、Q 扩展的关系

| 扩展        | 精度          | 描述             |
| :-------- | :---------- | :------------- |
| **F**     | 32 位（单精度）   | IEEE754 float  |
| **D**     | 64 位（双精度）   | IEEE754 double |
| **Q**     | 128 位（四精度）  | 高精度浮点          |
| **Zfinx** | 复用整数寄存器实现浮点 | 适合低功耗实现        |

> 如果支持 D 扩展，**必须也支持 F 扩展**（F 是 D 的基础）。

---

## 7.10 在 CSR 中的状态标志：FS 位

在 `mstatus`（或 `sstatus`）寄存器中，有两个与浮点相关的位：

* **FS[1:0]**：浮点状态字段

  | 值  | 含义               |
  | :- | :--------------- |
  | 00 | Off（不支持浮点）       |
  | 01 | Initial（已复位）     |
  | 10 | Clean（浮点已启用，未修改） |
  | 11 | Dirty（浮点寄存器已修改）  |

> 当 CPU 进行上下文切换时，操作系统会根据 FS 位判断是否需要保存/恢复浮点寄存器。

---

## 7.11 应用示例

### 示例 1：单精度浮点加法

```asm
flw     f1, 0(a0)       # 加载 A
flw     f2, 0(a1)       # 加载 B
fadd.s  f3, f1, f2      # f3 = f1 + f2
fsw     f3, 0(a2)       # 存储结果
```

### 示例 2：整数与浮点互转

```asm
lw       a0, 0(sp)       # 整数
fcvt.s.w f0, a0          # 转为 float
fcvt.w.s a1, f0          # 转回整数（取整）
```

---

## 7.12 F 扩展的生态地位

| 扩展    | 功能    | 是否可选    |
| :---- | :---- | :------ |
| M     | 乘除法   | 常用      |
| A     | 原子操作  | OS 必需   |
| **F** | 单精度浮点 | 科学计算常用  |
| D     | 双精度浮点 | 高性能计算必需 |
| C     | 压缩指令  | 常见优化    |

> ✅ 对于嵌入式系统，F 扩展可选；
> ✅ 对于通用计算机、GPU、科学计算、AI 芯片，F 扩展几乎必备。

---

## 7.13 总结表

| 分类      | 示例                                                | 功能      |
| :------ | :------------------------------------------------ | :------ |
| 算术类     | `fadd.s`, `fsub.s`, `fmul.s`, `fdiv.s`, `fsqrt.s` | 单精度加减乘除 |
| 比较类     | `feq.s`, `flt.s`, `fle.s`                         | 浮点比较    |
| 符号类     | `fsgnj.s`, `fabs.s`, `fneg.s`                     | 符号控制    |
| 转换类     | `fcvt.s.w`, `fcvt.w.s`, `fmv.x.w`, `fmv.w.x`      | 整数 ↔ 浮点 |
| 内存类     | `flw`, `fsw`                                      | 加载/存储   |
| 状态控制    | `fcsr`, `frm`, `fflags`                           | 异常与舍入控制 |
| CSR 状态位 | `FS`                                              | 浮点上下文管理 |

---

## 7.14 总结：

> **F 扩展**为 RISC-V 增加了完整的单精度浮点能力，
> 遵循 IEEE754 标准，提供独立的浮点寄存器堆与运算单元，
> 支持加减乘除、平方根、比较、转换等操作，
> 是实现科学计算与多媒体处理的核心扩展。

---

# 八、RISC-V扩展指令集-（D：双精度浮点）

## 8.1 D 扩展简介

| 项目   | 内容                                        |
| :--- | :---------------------------------------- |
| 扩展名  | D（Double-Precision Floating Point）        |
| 标准   | IEEE-754 2008                             |
| 精度   | 64 位（双精度浮点）                               |
| 依赖关系 | 必须同时支持 **F 扩展**                           |
| 寄存器  | 与 F 扩展共享同一组 32 个浮点寄存器（`f0–f31`），但宽度为 64 位 |

> ✅ D 扩展是 F 扩展的超集，支持所有 F 指令的双精度版本。

---

## 8.2 IEEE 754 双精度浮点格式

双精度浮点数（`double`）的结构如下：

| 字段                  | 位数          | 含义           |
| :------------------ | :---------- | :----------- |
| Sign                | 1 bit       | 符号位（0=正，1=负） |
| Exponent            | 11 bits     | 指数（偏移量 1023） |
| Fraction / Mantissa | 52 bits     | 尾数部分（隐含 1）   |
| **总计**              | **64 bits** |              |

计算公式：
$$
V = (-1)^{Sign} \times (1.\text{Fraction}) \times 2^{(Exponent - 1023)}
$$


与单精度相比：

* 精度更高（52 位尾数 vs 23 位尾数）
* 指数范围更广（±1023 vs ±127）
* 代价是占用更多寄存器空间与计算时间。

---

## 8.3 D 扩展的寄存器与状态管理

与 F 扩展共用：

| 名称      | 数量   | 位宽     | 说明                      |
| :------ | :--- | :----- | :---------------------- |
| 浮点寄存器   | 32 个 | 64 位   | `f0–f31`                |
| 控制状态寄存器 | 3 个  | 各 32 位 | `fflags`, `frm`, `fcsr` |

> ⚠️ 即使在 D 扩展中，`fcsr`、`frm`、`fflags` 的位宽仍是 32 位。

---

## 8.4 D 扩展的 CSR 控制

和 F 扩展完全一样，依然使用以下三个寄存器：

| CSR 名称   | 功能                                 |
| :------- | :--------------------------------- |
| `fflags` | 异常标志（NV, DZ, OF, UF, NX）           |
| `frm`    | 舍入模式（RNE, RTZ, RDN, RUP, RMM, DYN） |
| `fcsr`   | 复合寄存器（`frm` + `fflags`）            |

---

## 8.5 D 扩展指令分类与功能

D 扩展的所有指令都是 **F 扩展的“双精度版本”**，
指令格式、字段名称、功能完全一致，
唯一的区别是：
👉 操作数是 **64 位浮点数 (.D)**，而非 32 位 (.S)。

---

### ① 算术类指令（R-type）

| 指令                    | 功能      |
| :-------------------- | :------ |
| `fadd.d rd, rs1, rs2` | 双精度浮点加法 |
| `fsub.d rd, rs1, rs2` | 双精度减法   |
| `fmul.d rd, rs1, rs2` | 双精度乘法   |
| `fdiv.d rd, rs1, rs2` | 双精度除法   |
| `fsqrt.d rd, rs1`     | 双精度平方根  |

> 与 F 扩展一样，遵循 IEEE754 规则并由 `frm` 决定舍入模式。

---

### ② 符号与比较类指令

| 指令                     | 功能                  |
| :--------------------- | :------------------ |
| `fsgnj.d rd, rs1, rs2` | 用 rs2 的符号替换 rs1 的符号 |
| `fsgnjn.d`             | 取反符号                |
| `fsgnjx.d`             | 异或符号位（符号相反）         |
| `feq.d`                | 若相等则 rd=1           |
| `flt.d`                | 若 rs1 < rs2 则 rd=1  |
| `fle.d`                | 若 rs1 ≤ rs2 则 rd=1  |

---

### ③ 转换类指令

D 扩展新增了与 F 扩展之间的双向转换指令：

| 指令                  | 功能                 | 备注 |
| :------------------ | :----------------- | :- |
| `fcvt.s.d rd, rs1`  | 双精度 → 单精度（截断精度）    |    |
| `fcvt.d.s rd, rs1`  | 单精度 → 双精度          |    |
| `fcvt.w.d rd, rs1`  | 双精度 → 有符号整数（32 位）  |    |
| `fcvt.wu.d rd, rs1` | 双精度 → 无符号整数（32 位）  |    |
| `fcvt.d.w rd, rs1`  | 有符号整数 → 双精度        |    |
| `fcvt.d.wu rd, rs1` | 无符号整数 → 双精度        |    |
| `fcvt.l.d rd, rs1`  | 双精度 → 有符号长整型（64 位） |    |
| `fcvt.lu.d rd, rs1` | 双精度 → 无符号长整型       |    |
| `fcvt.d.l rd, rs1`  | 有符号长整型 → 双精度       |    |
| `fcvt.d.lu rd, rs1` | 无符号长整型 → 双精度       |    |

> D 扩展新增的 `fcvt.l*` 指令仅在 RV64 环境可用。

---

### ④ 加载 / 存储指令

| 指令                     | 功能          | 格式     |
| :--------------------- | :---------- | :----- |
| `fld rd, offset(rs1)`  | 从内存加载双精度浮点数 | I-type |
| `fsd rs2, offset(rs1)` | 将浮点数存入内存    | S-type |

> 与 F 扩展的 `flw` / `fsw` 对应，但操作 8 字节（64 位）数据。

---

## 8.6 D 扩展的指令编码格式

D 扩展使用与 F 扩展相同的基本编码结构：
opcode 均为 `1010011`（浮点计算指令通用 opcode）。

| 类别    | 指令格式           | opcode  |
| :---- | :------------- | :------ |
| 算术/比较 | R-type         | 1010011 |
| 加载    | I-type (`fld`) | 0000111 |
| 存储    | S-type (`fsd`) | 0100111 |

其中 funct7 的高位字段决定运算种类：
例如：

| 指令       | funct7  | funct3 | 备注    |
| :------- | :------ | :----- | :---- |
| `fadd.d` | 0000001 | 001    | 双精度加法 |
| `fsub.d` | 0000101 | 001    | 双精度减法 |
| `fmul.d` | 0001001 | 001    | 双精度乘法 |
| `fdiv.d` | 0001101 | 001    | 双精度除法 |

---

## 8.7 与 F 扩展的协作关系

D 扩展与 F 扩展共用硬件浮点单元（FPU），
但 FPU 必须支持：

* 64 位浮点寄存器宽度；
* 双精度加减乘除运算；
* 精度转换（F↔D）。

> 实际硬件中，FPU 内部通常支持双精度计算，
> 单精度操作只是用低 32 位参与计算。

---

## 8.8 上下文切换与状态位（FS 位）

在 `mstatus` 寄存器中有一个关键字段 **FS[1:0]**（浮点状态）：

| 值  | 含义              |
| :- | :-------------- |
| 00 | Off（禁用浮点单元）     |
| 01 | Initial（初始化状态）  |
| 10 | Clean（已启用但未修改）  |
| 11 | Dirty（浮点寄存器被修改） |

> 操作系统利用 FS 位判断是否需要在上下文切换时保存/恢复浮点寄存器（`f0–f31`）。

---

## 8.9 硬件实现要点

D 扩展要求 FPU 支持：

1. **双精度加减乘除逻辑单元**

   * 可在单周期或多周期完成；
2. **规范化与舍入电路**

   * 遵循 IEEE 754 舍入模式；
3. **异常检测**

   * NV, DZ, OF, UF, NX 五种异常；
4. **寄存器多精度支持**

   * 64 位寄存器能存放单精度或双精度数据；
5. **内存总线对齐**

   * `fld` / `fsd` 要求地址 8 字节对齐。

---

## 8.10 D 扩展的使用示例

### 示例 1：双精度浮点加法

```asm
fld     f1, 0(a0)       # 加载 double A
fld     f2, 0(a1)       # 加载 double B
fadd.d  f3, f1, f2      # f3 = A + B
fsd     f3, 0(a2)       # 存储结果
```

### 示例 2：类型转换（整数 ↔ 双精度）

```asm
ld        a0, 0(sp)        # 整数
fcvt.d.l  f0, a0           # 整数 -> double
fcvt.l.d  a1, f0           # double -> 整数
```

### 示例 3：单精度与双精度互转

```asm
flw      f1, 0(a0)         # 加载单精度
fcvt.d.s f2, f1            # 转为双精度
fcvt.s.d f3, f2            # 再转回单精度
```

---

## 8.11 D 扩展与 Q 扩展的关系

| 扩展    | 精度            | 必须依赖 | 说明              |
| :---- | :------------ | :--- | :-------------- |
| **F** | 单精度 (32-bit)  | -    | IEEE 754 float  |
| **D** | 双精度 (64-bit)  | F    | IEEE 754 double |
| **Q** | 四精度 (128-bit) | D    | 高精度（科学计算、AI）    |

> ⚠️ 因此：
>
> * 支持 D 的实现必须同时支持 F；
> * 支持 Q 的实现必须同时支持 F 和 D。

---

## 8.12 D 扩展的典型应用场景

| 领域    | 应用                  |
| :---- | :------------------ |
| 科学计算  | 矩阵计算、数值积分、FFT       |
| 金融分析  | 高精度小数运算             |
| 图形渲染  | 精确几何计算              |
| 机器学习  | 训练阶段高精度运算           |
| 编译器支持 | C/C++ `double` 类型运算 |

> D 扩展是 **通用 CPU（如 Linux 平台）标配**，
> 在嵌入式或低功耗芯片上可选。

---

## 8.13 总结表

| 类别   | 指令示例                                                                   | 说明         |
| :--- | :--------------------------------------------------------------------- | :--------- |
| 算术   | `fadd.d`, `fsub.d`, `fmul.d`, `fdiv.d`, `fsqrt.d`                      | 基本浮点计算     |
| 比较   | `feq.d`, `flt.d`, `fle.d`                                              | 浮点比较       |
| 符号   | `fsgnj.d`, `fsgnjn.d`, `fsgnjx.d`                                      | 符号控制       |
| 转换   | `fcvt.d.s`, `fcvt.s.d`, `fcvt.d.w`, `fcvt.w.d`, `fcvt.d.l`, `fcvt.l.d` | 类型转换       |
| 存取   | `fld`, `fsd`                                                           | 加载与存储      |
| 状态控制 | `fflags`, `frm`, `fcsr`                                                | 异常与舍入控制    |
| 寄存器  | `f0–f31`                                                               | 64 位浮点寄存器堆 |
| 依赖   | 必须支持 F 扩展                                                              |            |


> **D 扩展（Double-Precision Floating Point）**
> 是 RISC-V 的高精度浮点扩展，
> 遵循 IEEE-754 双精度标准，
> 支持加减乘除、平方根、比较与类型转换，
> 使用 64 位浮点寄存器，
> 是 F 扩展的超集，也是 Q 扩展的基础。

---

# 九、RISC-V扩展指令集-（V：向量拓展）

## 9.1 V 扩展简介

* 扩展名：**V = Vector Extension**（向量扩展）
* 作用：为 RISC-V 增加向量寄存器、向量指令、可变向量长度（vector length agnostic）、掩码执行、分散／聚集（gather/scatter）等，以支持数据并行运算。 ([RISC-V International][1])
* 当前状态：已发展至版本 1.0（或接近 ratification 状态）([GitHub][2])
* 核心理念：向量寄存器长度（VLEN）是 **可变的**，软件不需要针对固定宽度手动拆分（strip-mine）循环。([RISC-V International][3])
* 特点包括：

  * 支持各种元素宽度（SEW）与寄存器组合（LMUL）
  * 支持掩码执行（Masked vector）
  * 支持加载／存储不同访问模式（线性、步长、聚集／分散）
  * 向量指令与标量代码高度结合，且二进制兼容不同 VLEN 实现
  * 支持整数／浮点／固定点多种数据类型

---

## 9.2 为什么需要 V 扩展（设计动机）

* 传统的 “短向量 SIMD” 架构（如在 x86、ARM 上）在向量宽度变化时常需修改代码。RISC-V 的 V 扩展通过可变向量长度（Vector Length Agnostic）解决了这一痛点。([RISC-V International][3])
* 对于 AI、信号处理、科学计算而言，处理的数据往往非常大，**需要向量并行**。V 扩展提供通用的硬件支持，而不是专用加速器。
* 软件可编写一次、在不同向量宽度硬件上运行并获得性能提升 —— 提高可移植性与寿命。

---

## 9.3 V 扩展的体系结构模型（寄存器 + CSR +参数）

### 9.3.1 向量寄存器

* 向量扩展定义了一个“向量寄存器文件”，例如 **v0 … v31**（共 32 个向量寄存器）
* 每个寄存器的宽度为 VLEN bits（VLEN 是实现定义的常量，通常为 128、256、512 位或更高；但必须为 2 的幂）
* 向量寄存器根据当前设置的 SEW（Selected Element Width）和 LMUL（寄存器组倍数）拆分为若干元素。

### 9.3.2 关键可配置参数

* **ELEN**：元素宽度最大值（bits），ELEN ≥ 8 且为 2 的幂。
* **VLEN**：每个向量寄存器位宽，VLEN ≥ ELEN，且为 2 的幂。
* **SEW**（Selected Element Width）：当前操作中每个元素宽度（例如 8 bit、16 bit、32 bit、64 bit 等）
* **LMUL**（Vector Register Group Multiplier）：指定一个操作可能使用多个连续向量寄存器组成一个寄存器群（group）进行大元素宽度或更多并行度。
* **VL**：当前实际处理元素数（vector length） — 由指令设置，可小于或等于该硬件支持的最大。

### 9.3.3 新增 CSR（控制/状态寄存器）

向量扩展还定义了一些新的寄存器（CSR）以控制向量状态。典型有：

| 名称                                | 描述                          | 地址示例              | 参考                   |
| --------------------------------- | --------------------------- | ----------------- | -------------------- |
| `vl`                              | 向量长度（当前有效元素数）               | CSR 地址例如 0xC20    | ([Five EmbedDev][4]) |
| `vtype`                           | 表示当前的向量元素宽度、LMUL、掩码控制等      | CSR 地址 0xC21      | ([Five EmbedDev][4]) |
| `vlenb`                           | 向量寄存器总位宽/8（即寄存器字节长度）        | CSR 地址 0xC22      | ([Five EmbedDev][4]) |
| `vstart`, `vxsat`, `vxrm`, `vcsr` | 其它控制/状态寄存器（如定点饱和、舍入模式、状态标志） | 例如地址 0x008、0x009… | ([Five EmbedDev][4]) |

### 9.3.4 与特权状态相关位

* 在 `mstatus` 寄存器中，向量状态字段 `VS`（Vector State）被定义（例如 `mstatus.VS[1:0]`）以控制向量单元是否已启用或是否处于“dirty”状态。([Five EmbedDev][4])
* 这类似于浮点扩展中的 `FS` 字段。

---

## 9.4 V 扩展指令分类与编程模型简介

向量扩展提供了大量指令，以下为核心类别（细节在规范中非常丰富，此处为概览）。

### 9.4.1 向量加载/存储

* **Vector Load / Store**：从内存加载/存储向量寄存器组，例如 `vlw.v`, `vsw.v`（以字为单位）或更宽元素与分散／聚集形式。
* 支持 **步长访问（stride）**、**聚集/分散（gather/scatter）** 模式。

### 9.4.2 向量算术／逻辑操作

* 各种元素宽度的向量加、减、乘、除（整数／浮点）、逻辑与、或、异或等。
* 与掩码（mask）结合，实现对部分元素操作或屏蔽。
* 支持 **向量-标量**操作（向量与标量交互）与 **向量-向量**操作。

### 9.4.3 掩码与谓词、尾元素处理

* 每条向量指令可带掩码寄存器，控制哪些元素有效。
* 对于 “尾（tail）” 元素（即少于 VL 的元素）有两种策略：**尾元素为零（vta = 0）** 或 **保留（vta = 1）**。
* 对掩码为零的元素也有处理策略（vma 位控制，mask-agnostic vs mask-aware）([Five EmbedDev][4])

### 9.4.4 向量长度可变性（Vector Length Agnostic）

* 软件通过 `vsetvli` 或 `vsetvl` 指令设置 VL（向量长度）和相关配置。
* 同一段向量化程序可在不同 VLEN 的硬件上运行，只要确保支持的 SEW/LMUL 等特性。([RISC-V International][1])

### 9.4.5 编程模型注意

* 向量寄存器组作为一个整体使用，可能占用多个物理寄存器（由 LMUL 决定）。
* 在编译器（如 LLVM）中，向量类型被表示为可扩展向量 `<vscale x N x ty>`。([llvm.org][5])
* 代码需考虑对齐、掩码、尾处理、分段循环（strip-mining）但规范力求减少该负担。

---

## 9.5 V 扩展编码与格式要点（部分）

虽然向量指令种类繁多，但几个关键编码、字段你必须掌握：

* 向量指令通常使用特殊的 opcode（例如用于 vector load/store 和 vector arithmetic）。
* CSR 指令 `vsetvl`, `vsetvli` 设置向量长度和类型。
* `vtype` 寄存器中包含字段如：

  * `vsew[2:0]`：选定元素宽度编码
  * `vlmul[2:0]`：组倍数编码
  * `vta`, `vma`：尾/掩码策略位
  * `vill`：非法位（用于保留将来扩展） ([Five EmbedDev][4])
* 指令解码器根据 `vtype`, `vl` 等决定操作行为。

---

## 9.6 硬件实现注意事项

* 向量寄存器文件规模大（例如 VLEN = 512 bits × 32 regs）——对面积、功耗提出挑战。
* 支持不同 SEW、LMUL 下的寄存器组化、寄存器重命名、寄存器分配更复杂。
* 支持掩码执行、尾部处理、分散/聚集存取需要额外逻辑。
* 向量长度可变，需在硬件中动态响应 `vl` 设置。
* 上下文切换时，若向量状态 “Dirty”，操作系统需保存/恢复向量寄存器。借助 `mstatus.VS` 位可优化。
* 与缓存、内存系统紧密耦合：高带宽、低延迟访问对性能关键。
* 编译器／微架构合作：要充分利用向量并行，减少流水线气泡 (bubbles) 和碎片。

---

## 9.7 典型应用场景

* **机器学习**：矩阵运算、张量操作、大规模向量乘加（如向量-矩阵乘）。
* **信号处理／多媒体**：滤波、FFT、卷积、音频处理。
* **科学计算 / HPC**：大规模浮点运算、多维数组处理。
* **数据并行任务**：批量数据转换、加速数据库、图形运算。
* **嵌入式向量加速**：低功耗设备也可实现小的向量扩展版本。([RISC-V International][3])

---

## 9.8 总结

> V 扩展（Vector Extension）为 RISC-V 提供了强大的向量并行能力，引入 32 个向量寄存器、可变向量长度（VLEN）、支持多种元素宽度（SEW）、寄存器组（LMUL）、掩码执行、尾部处理、载入/存储多种模式，从而实现高度可移植、可扩展的数据并行运算模型。

---
# 十、RISC-V扩展指令集-（C：压缩）

## 10.1 C 扩展简介

| 项目   | 内容                                                                             |
| :--- | :----------------------------------------------------------------------------- |
| 扩展名  | **C = Compressed extension**                                                   |
| 全称   | RVC（RISC-V Compressed Instructions）                                            |
| 功能   | 提供 **16 位短指令**，与标准 32 位指令等价，减少代码体积                                             |
| 标准来源 | RISC-V “Unprivileged ISA Specification” Vol. I, Section “C Standard Extension” |
| 依赖   | 可与 RV32I / RV64I / RV128I 等任意基础集配合使用                                           |
| 指令宽度 | 16 位（半字） vs 标准指令 32 位（一个字）                                                     |

---

## 10.2 设计动机

RISC-V 是“定长指令”架构（每条标准指令 32 位），
这样虽然解码简单，但程序代码体积偏大。

在嵌入式系统（如 MCU、IoT 芯片）中：

* **存储空间极为有限**
* **指令缓存容量小**
* **功耗敏感**

因此，RISC-V 提出 “C 扩展” 来压缩常见指令。

🧩 **目标：**

* 让汇编层面的常见操作（load/store/jump/move/addi等）
  能用一条 16 位短指令表示；
* 确保压缩与非压缩指令可以混合执行，保持兼容性；
* 不引入新的寄存器或语义。

---

## 10.3 C 扩展的总体思路

C 扩展定义了一种**“16 位指令格式”**，称为 **Compressed Instruction**。
它和标准 32 位指令在内存中可以交替混合使用。
CPU 通过指令最低两位区分指令宽度：

| 最低两位（`instr[1:0]`） |     含义    |
| :----------------: | :-------: |
|        `11`        | 标准 32 位指令 |
|  `00`, `01`, `10`  | 压缩 16 位指令 |

> ✅ 所以取指时，CPU 先读 16 bits；若发现 `11`，则再取 16 bits 拼成完整的 32 位指令。

---

## 10.4 C 扩展中的寄存器命名约定

压缩指令为了节省位数，采用了 **寄存器编号压缩策略**：

* 普通 32 位寄存器编号：x0 ~ x31
* 压缩指令中只用 **8 个常用寄存器**：

  ```
  x8–x15  （即 s0/a0/a1/a2/a3/a4/a5/a6/a7）
  ```
* 这些寄存器在压缩指令中被重命名为 **“紧凑寄存器” crs**：

  ```
  crs0 = x8,  crs1 = x9,  ... ,  crs7 = x15
  ```
* 用 `rd′`, `rs1′`, `rs2′` 表示压缩寄存器。

这样只需 3 bits 就能表示寄存器，而非 5 bits。

---

## 10.5 压缩指令的总体分类

RISC-V C 扩展定义了约 **30 条 16 位指令**，
可以分为以下几类👇：

| 分类          | 示例                                                 | 功能             |
| :---------- | :------------------------------------------------- | :------------- |
| 📦 加载/存储    | `c.lw`, `c.sw`, `c.ld`, `c.sd`, `c.lwsp`, `c.swsp` | 压缩版 load/store |
| 🧮 算术与立即数操作 | `c.add`, `c.addi`, `c.li`, `c.lui`                 | 压缩版算术运算        |
| 🔁 跳转/分支    | `c.j`, `c.jal`, `c.beqz`, `c.bnez`                 | 跳转与条件分支        |
| 🔄 移动与返回    | `c.mv`, `c.jr`, `c.jalr`, `c.ret`                  | 寄存器间移动、函数返回    |
| 🔧 其他       | `c.and`, `c.or`, `c.xor`, `c.sub`                  | 压缩版逻辑操作        |
| 🛠️ 特殊      | `c.nop`, `c.ebreak`                                | 特殊控制指令         |

---

## 10.6 编码格式（概览）

C 扩展定义了多种 16-bit 格式，
通常以 `quadrant`（四分区）分类：

| Quadrant | bits[1:0] | 常见指令                   |
| :------- | :-------- | :--------------------- |
| Q0       | `00`      | Load/Store 类           |
| Q1       | `01`      | 算术 / Jump / Immediate  |
| Q2       | `10`      | Move / Branch / Return |
| Q3       | `11`      | 保留，用于32位指令             |

例如：

```
[15:13] funct3 | [12:2] 立即数 / 寄存器编码 | [1:0] quadrant
```

---

## 10.7 常见指令详解

### 1️⃣ 加载 / 存储指令

| 指令                        | 功能                       | 对应标准指令                |
| :------------------------ | :----------------------- | :-------------------- |
| `c.lw rd′, offset(rs1′)`  | 从内存加载 32 位数据             | `lw rd, offset(rs1)`  |
| `c.sw rs2′, offset(rs1′)` | 存储 32 位数据                | `sw rs2, offset(rs1)` |
| `c.ld`, `c.sd`            | 64 位系统下加载/存储 double word | `ld`, `sd`            |
| `c.lwsp rd, offset(sp)`   | 从栈中加载                    | `lw rd, offset(sp)`   |
| `c.swsp rs2, offset(sp)`  | 写入栈中                     | `sw rs2, offset(sp)`  |

---

### 2️⃣ 算术与立即数指令

| 指令                    | 功能                 | 等价 |
| :-------------------- | :----------------- | :- |
| `c.addi rd, imm`      | `addi rd, rd, imm` |    |
| `c.li rd, imm`        | `addi rd, x0, imm` |    |
| `c.lui rd, imm`       | `lui rd, imm`      |    |
| `c.addi4spn rd′, imm` | `addi rd, sp, imm` |    |
| `c.addi16sp imm`      | `addi sp, sp, imm` |    |
| `c.nop`               | `addi x0, x0, 0`   |    |

---

### 3️⃣ 跳转 / 分支类

| 指令                    | 功能       | 对应                    |
| :-------------------- | :------- | :-------------------- |
| `c.j offset`          | 跳转       | `jal x0, offset`      |
| `c.jal offset`        | 跳转并链接    | `jal x1, offset`      |
| `c.beqz rs1′, offset` | 条件分支（=0） | `beq rs1, x0, offset` |
| `c.bnez rs1′, offset` | 条件分支（≠0） | `bne rs1, x0, offset` |

---

### 4️⃣ 移动 / 逻辑运算 / 返回

| 指令                                | 功能                | 对应 |
| :-------------------------------- | :---------------- | :- |
| `c.mv rd, rs2`                    | `add rd, x0, rs2` |    |
| `c.add rd, rs2`                   | `add rd, rd, rs2` |    |
| `c.sub`, `c.and`, `c.or`, `c.xor` | 压缩版逻辑运算           |    |
| `c.jr rs1`                        | `jalr x0, 0(rs1)` |    |
| `c.jalr rs1`                      | `jalr x1, 0(rs1)` |    |
| `c.ret`                           | `jalr x0, 0(ra)`  |    |

---

## 10.8 C 扩展与其他扩展的关系

| 扩展     | 是否可共存   | 说明                                         |
| :----- | :------ | :----------------------------------------- |
| M 扩展   | ✅       | 乘除法指令不受影响                                  |
| A 扩展   | ✅       | 原子指令仍为 32-bit                              |
| F/D 扩展 | ✅       | 浮点压缩指令如 `c.flw`, `c.fsw`, `c.fld`, `c.fsd` |
| V 扩展   | ✅（部分支持） | 向量扩展可定义压缩向量加载/存储                           |
| Zicsr  | ✅       | 可与 `csrr` 类指令混用                            |

---

## 10.9 指令取址与执行机制

CPU 取指时可识别指令宽度：

```
if (instr[1:0] == 0b11)
    => decode 32-bit
else
    => decode 16-bit (compressed)
```

程序计数器（PC）仍以字节递增：

* 16 位指令执行后：PC += 2
* 32 位指令执行后：PC += 4

所有压缩指令的执行语义与 32 位版本完全相同。

---

## 10.10 C 扩展的硬件实现要点

| 方面          | 内容                         |
| :---------- | :------------------------- |
| **取指阶段**    | 支持 16/32 混合长度解码（PC+2 / +4） |
| **解码阶段**    | 需识别压缩寄存器编码与立即数重组逻辑         |
| **流水线处理**   | 语义等价，执行阶段无需改动              |
| **异常与中断**   | 触发时 PC 指向 16 位指令起始地址       |
| **调试 / 断点** | 支持半字对齐断点                   |

> 实现上最关键的是前端解码单元必须能快速区分 16/32 位指令并扩展成内部标准格式。

---

## 10.11 C 扩展带来的好处

| 优势                   | 说明                  |
| :------------------- | :------------------ |
| 💾 **减小代码体积**        | 可减少 25%～40% 的指令存储空间 |
| ⚡ **提高 I-cache 命中率** | 更多指令装入缓存            |
| 🔋 **降低功耗**          | 内存带宽需求减少            |
| 🧩 **完全兼容**          | 解压后语义与标准指令完全一致      |
| 🚀 **编译器自动生成**       | GCC/LLVM 已支持自动压缩优化  |

---

## 10.12 示例代码

```asm
# 普通版本
addi  sp, sp, -16
sw    ra, 12(sp)
sw    s0, 8(sp)
addi  s0, sp, 16

# 压缩版（C 扩展启用后）
c.addi16sp  -16
c.swsp      ra, 12
c.swsp      s0, 8
c.addi      s0, sp, 16
```

> 同样功能下，C 版只需一半的程序空间。

---

## 10.13 总结表

| 类别    | 示例                                 | 说明     |
| :---- | :--------------------------------- | :----- |
| 加载/存储 | `c.lw`, `c.sw`, `c.lwsp`, `c.swsp` | 16 位访存 |
| 算术    | `c.add`, `c.addi`, `c.li`, `c.lui` | 压缩版运算  |
| 控制流   | `c.j`, `c.beqz`, `c.bnez`          | 压缩跳转   |
| 逻辑操作  | `c.and`, `c.or`, `c.xor`, `c.sub`  | 逻辑类压缩  |
| 特殊    | `c.nop`, `c.ebreak`, `c.ret`       | 控制类    |
| 兼容性   | 可与所有标准与扩展指令混合使用                    |        |

---

## 10.14 总结

> **C 扩展（RVC）** 是 RISC-V 的“压缩指令集”，
> 它让常见 32 位指令能以 16 位形式表示，
> 大幅减少代码体积，提高缓存利用率与能效，
> 同时与标准指令完全兼容，是嵌入式系统的核心扩展之一。

---

# 十一、RISC-V特权级指令

## 11.1 特权级 ISA 的总体结构

RISC-V 特权级指令集规范（Privileged Architecture Spec）定义了 **不同权限模式下的控制机制**，主要有三个模式：

| 模式              | 英文名  | 缩写 | 权限   | 典型用途               |
| --------------- | ---- | -- | ---- | ------------------ |
| Machine Mode    | M 模式 | M  | 最高权限 | 固件、Bootloader、裸机程序 |
| Supervisor Mode | S 模式 | S  | 中等权限 | 操作系统内核（如 Linux）    |
| User Mode       | U 模式 | U  | 最低权限 | 普通用户程序             |

> 有的系统（如嵌入式 MCU）只实现 M 模式，而支持操作系统的系统（如 Linux）会实现 M+S+U 三层。

---

## 11.2 CSR（Control and Status Registers）控制状态寄存器体系

特权级的核心是 **CSR（控制与状态寄存器）**。
它们存放 CPU 的运行状态、控制信息、中断管理、页表地址等。

> 每个 CSR（控制与状态寄存器）都有一个 **12 位地址**，其中**高 2 位（即 [11:10]）定义了它的访问权限等级**：

| 位 [11:10] | 特权级         | 说明             |
| --------- | ----------- | -------------- |
| `00`      | 用户态 (U)     | 用户级 CSR        |
| `01`      | 监督态 (S)     | 监督级 CSR        |
| `10`      | 虚拟化态 (H，可选) | Hypervisor CSR |
| `11`      | 机器态 (M)     | 机器级 CSR        |


> 这意味着：
>
> - 地址 0x000 ~ 0x0FF：用户态 CSR
>
> - 地址 0x100 ~ 0x1FF：监督态 CSR
>
> - 地址 0x200 ~ 0x2FF：虚拟化 CSR
>
> - 地址 0x300 ~ 0x3FF：机器态 CSR


---

### CSR 地址空间按照模式划分：

| 特权级           | CSR 地址范围    | 说明                                         |
| ------------- | ----------- | ------------------------------------------ |
| **U 模式**（用户态） | 0x000–0x0FF | 用户级 CSR（例如 fflags、frm、fcsr）                |
| **S 模式**（监督态） | 0x100–0x1FF | 监督级 CSR（例如 sstatus、sie、stvec）              |
| **H 模式**（虚拟化） | 0x200–0x2FF | Hypervisor CSR（可选）                         |
| **M 模式**（机器态） | 0x300–0x3FF | 机器级 CSR（例如 mstatus、misa、mtvec、mepc、mcause） |
| **保留/自定义**    | 0x400–0xFFF | 厂商自定义扩展 CSR                                |

---

### 📘 CSR 的主要类别

| 功能类型        | 作用       | 例子                                                    |
| ----------- | -------- | ----------------------------------------------------- |
| **状态寄存器**   | 存储当前运行状态 | `mstatus`, `sstatus`                                  |
| **中断管理**    | 中断使能、挂起位 | `mie`, `mip`, `sie`, `sip`                            |
| **异常处理**    | 保存异常信息   | `mepc`, `mcause`, `mtval`                             |
| **陷入入口**    | 中断向量地址   | `mtvec`, `stvec`                                      |
| **页表与内存保护** | 虚拟内存根地址  | `satp`（Supervisor Address Translation and Protection） |
| **性能计数器**   | 统计信息     | `mcycle`, `minstret`                                  |

---

## 11.3 特权级指令（Privilege-Level Instructions）

下面是特权级 RISC-V 指令的核心部分。
它们可以分为以下几类👇：

---

### ① CSR 访问指令（控制与状态寄存器操作）

这组是特权级中最重要的一类，用于读写 CSR。

| 指令                           | 作用                           | 示例                      |
| ---------------------------- | ---------------------------- | ----------------------- |
| `CSRRW rd, csr, rs1`         | 读 CSR 到 `rd`，同时写 `rs1` 到 CSR | `csrrw x1, mstatus, x2` |
| `CSRRS rd, csr, rs1`         | 读 CSR，同时设置 CSR 中由 `rs1` 指定的位 | `csrrs x5, mie, x10`    |
| `CSRRC rd, csr, rs1`         | 读 CSR，同时清除 CSR 中由 `rs1` 指定的位 | `csrrc x0, mie, x11`    |
| `CSRRWI`, `CSRRSI`, `CSRRCI` | 上面三条的立即数版本                   | `csrrwi x0, 0x300, 1`   |

> ✅ 这些指令是访问系统寄存器的唯一合法方式。
> ❌ 用户态（U 模式）通常不能执行这些操作，否则触发异常。

---

### ② 特权返回指令（返回低权限模式）

| 指令     | 含义            | 用途           |
| ------ | ------------- | ------------ |
| `MRET` | 从机器模式返回到上一级模式 | 用于从 M 态陷入返回  |
| `SRET` | 从监督模式返回到用户态   | 系统调用或异常返回时使用 |
| `URET` | 从用户模式返回（极少用）  | 嵌入式安全场景      |

这些返回指令会：

1. 从 `mepc` / `sepc` 取回程序计数器；
2. 恢复 `mstatus` / `sstatus` 中保存的权限标志；
3. 返回到陷入前的执行点。

---

### ③ 系统调用与陷入指令

| 指令       | 功能                     | 说明                   |
| -------- | ---------------------- | -------------------- |
| `ECALL`  | 发起系统调用（Exception Call） | 从当前模式陷入更高权限级别（如 U→S） |
| `EBREAK` | 调试断点                   | 用于调试器断点陷入 M 模式       |
| `WFI`    | Wait For Interrupt     | CPU 进入低功耗等待中断状态      |

#### 🚨 系统调用流程举例：

```asm
# 用户态程序调用系统服务
ecall

# CPU 自动：
#   1. 保存当前 PC 到 sepc
#   2. 设置 scause = 9 (ECALL from U-mode)
#   3. 跳转到 stvec (内核异常处理入口)
#   4. OS 内核处理后执行 sret 返回
```

---

### ④ 地址与内存管理指令

#### (1) 虚拟内存页表管理

| 指令                    | 功能                                          | 说明              |
| --------------------- | ------------------------------------------- | --------------- |
| `SFENCE.VMA rs1, rs2` | 刷新页表缓存（TLB）                                 | 当修改页表后必须执行，用于内核 |
| `SATP`（寄存器）           | Supervisor Address Translation & Protection | 控制页表基地址与地址空间 ID |

#### (2) 典型使用

```asm
# 切换页表
csrw satp, x10
sfence.vma x0, x0  # 清空TLB
```

---

### ⑤ 中断与异常控制

这些并非单独指令，而是通过 **CSR 操作** 来控制：

| 功能       | 相关寄存器                | 说明              |
| -------- | -------------------- | --------------- |
| 设置中断入口   | `mtvec`, `stvec`     | 保存异常/中断处理函数入口地址 |
| 启用/关闭中断  | `mie`, `mstatus.MIE` | 控制全局中断使能        |
| 读取中断状态   | `mip`                | 挂起中断标志          |
| 保存异常返回地址 | `mepc`, `sepc`       | 记录异常前 PC        |
| 异常原因     | `mcause`, `scause`   | 表示陷入类型（中断/异常）   |
| 异常附加信息   | `mtval`, `stval`     | 记录出错地址等         |

---

## 11.4 陷入与返回（Trap Mechanism）

RISC-V 的特权架构定义了统一的 **陷入处理机制（Trap）**，包括：

| 类型            | 触发来源        | 执行模式变化   | 说明              |
| ------------- | ----------- | -------- | --------------- |
| **Exception** | 指令执行错误或系统调用 | 同模式或上级模式 | 例如除零、非法指令、页错误   |
| **Interrupt** | 外部设备或定时器信号  | 同模式或上级模式 | 通过 `mie/mip` 控制 |

### 流程示意：

1. 当前指令触发异常/中断；
2. CPU 保存当前 PC → `mepc` 或 `sepc`；
3. 设置异常原因 → `mcause` 或 `scause`；
4. 跳转到异常入口 `mtvec` 或 `stvec`；
5. 执行内核处理；
6. `mret` / `sret` 返回原执行点。

---

## 11.5 特权级寄存器与指令对应速查表

| 功能类别 | 寄存器/指令                     | 模式  | 说明          |
| ---- | -------------------------- | --- | ----------- |
| 异常入口 | `mtvec`, `stvec`           | M/S | 中断/异常处理函数地址 |
| 异常返回 | `mepc`, `sepc`             | M/S | 保存返回地址      |
| 异常类型 | `mcause`, `scause`         | M/S | 保存陷入原因      |
| 附加信息 | `mtval`, `stval`           | M/S | 附带异常信息      |
| 状态控制 | `mstatus`, `sstatus`       | M/S | 权限状态控制      |
| 返回指令 | `mret`, `sret`             | M/S | 异常返回        |
| 系统调用 | `ecall`                    | All | 发起陷入        |
| 调试   | `ebreak`                   | All | 断点陷入        |
| 内存管理 | `satp`, `sfence.vma`       | S   | 页表管理        |
| 中断控制 | `mie`, `mip`, `sie`, `sip` | M/S | 控制中断使能      |

---

## 11.6 小结：特权级 ISA 的本质

| 层次         | 功能目标         | 典型组件                                    |
| ---------- | ------------ | --------------------------------------- |
| **用户态（U）** | 普通应用执行       | 普通指令（RV32I/M/F/D/...）                   |
| **监督态（S）** | OS 内核运行、虚拟内存 | `sstatus`, `satp`, `sret`, `sfence.vma` |
| **机器态（M）** | 启动、固件、中断管理   | `mstatus`, `mepc`, `mtvec`, `mret`      |

> 简言之：
>
> * **用户态执行应用；**
> * **监督态执行操作系统；**
> * **机器态控制硬件。**

---

# 十二、CSR寄存器体系
非常棒的问题👏！
你问到了 **RISC-V 特权级架构**（Privilege Spec）的核心内容：
——不同特权模式（U、S、M）下的 **CSR 寄存器访问权限与层次关系**。

这个问题我们分两部分讲清楚👇

---

## 12.1 RISC-V 特权级架构回顾

RISC-V 定义了三个主要的 **特权级（Privilege Level）**：

| 特权级                 | 缩写   | 编码 | 权限说明                         |
| :------------------ | :--- | :- | :--------------------------- |
| **Machine Mode**    | M 模式 | 11 | 最高权限，控制整个系统（类似 x86 的 Ring 0） |
| **Supervisor Mode** | S 模式 | 01 | 管理操作系统（可访问部分控制寄存器）           |
| **User Mode**       | U 模式 | 00 | 用户程序级，访问权限最低                 |

> 有些实现还支持 H 模式（Hypervisor）扩展，但一般在基础架构中仅 M/S/U 三种。

---

## 12.2 CSR（控制与状态寄存器）总览

RISC-V 使用 CSR 寄存器（Control and Status Register）进行：

* 中断与异常控制
* 特权级切换
* 内存管理（页表、satp）
* 性能监控等

---

## 12.3 CSR 地址空间结构（根据特权级划分）

CSR 是按照地址编码的高位（bit[9:8]）划分权限范围的：

| CSR 地址范围      | 可访问特权级     | 说明                  |
| :------------ | :--------- | :------------------ |
| 0x000 – 0x0FF | **U-mode** | 用户级 CSR             |
| 0x100 – 0x1FF | **S-mode** | 管理系统级 CSR           |
| 0x300 – 0x3FF | **M-mode** | 机器级 CSR             |
| 0x200 – 0x2FF | （H-mode）   | Hypervisor 扩展使用（可选） |

> ✅ **高特权级总是能访问低特权级 CSR**。
> 即：
> M 模式可以访问全部 CSR，
> S 模式可访问 S/U 模式的 CSR，
> U 模式仅能访问自己的 CSR。

---

## 12.4 各模式下常用 CSR 寄存器分类

### 1️⃣ M 模式（Machine Mode）专有 CSR

| 寄存器                       | 地址                    | 功能描述                        |
| :------------------------ | :-------------------- | :-------------------------- |
| **mstatus**               | 0x300                 | 全局状态控制（中断使能、特权切换、虚拟化控制）     |
| **misa**                  | 0x301                 | 指示 CPU 支持的 ISA 扩展（如 IMACFD） |
| **medeleg / mideleg**     | 0x302 / 0x303         | 将异常/中断委托给 S 模式              |
| **mie / mip**             | 0x304 / 0x344         | 中断使能与挂起位                    |
| **mtvec**                 | 0x305                 | 异常入口地址（Trap Vector）         |
| **mscratch**              | 0x340                 | 保存 M 模式切换上下文的临时寄存器          |
| **mepc / mcause / mtval** | 0x341 / 0x342 / 0x343 | Trap 返回地址、异常原因、故障信息         |
| **mcycle / minstret**     | 0xB00 / 0xB02         | 性能计数器                       |

>  M 模式控制整个 CPU 的异常委托、时钟计数和中断管理，是所有模式的“根”。

---

### 2️⃣ S 模式（Supervisor Mode）CSR

| 寄存器                       | 地址                    | 功能描述                    |
| :------------------------ | :-------------------- | :---------------------- |
| **sstatus**               | 0x100                 | S 模式状态寄存器（从 mstatus 派生） |
| **sie / sip**             | 0x104 / 0x144         | 中断使能与挂起（仅管理 S 模式相关位）    |
| **stvec**                 | 0x105                 | S 模式 Trap 向量基址          |
| **sscratch**              | 0x140                 | S 模式上下文临时保存             |
| **sepc / scause / stval** | 0x141 / 0x142 / 0x143 | 异常处理相关信息                |
| **satp**                  | 0x180                 | 页表基址与地址空间标识（MMU）        |

> 🧠 注意：很多 S 模式寄存器是 “m 模式寄存器的子集或镜像”。

---

### 3️⃣ U 模式（User Mode）CSR

| 寄存器                                  | 地址                            | 功能描述                     |
| :----------------------------------- | :---------------------------- | :----------------------- |
| **ustatus**                          | 0x000                         | 用户状态寄存器（部分 mstatus 位的影射） |
| **uie / uip**                        | 0x004 / 0x044                 | 用户级中断使能与挂起               |
| **utvec**                            | 0x005                         | 用户级 Trap 向量              |
| **uscratch / uepc / ucause / utval** | 0x040 / 0x041 / 0x042 / 0x043 | 用户级异常上下文信息               |
| **fflags / frm / fcsr**              | 0x001 / 0x002 / 0x003         | 浮点状态寄存器（在 F/D 扩展中使用）     |

> ⚠️ 但在多数系统实现中，U 模式 trap 处理被委托给 S 模式，因此很多 `u*` CSR 可能被实现为只读或未定义。

---

## 12.5 总结

| 模式                    | 可访问 CSR       | 示例                                    | 备注         |
| :-------------------- | :------------ | :------------------------------------ | :--------- |
| **M 模式**              | 所有 CSR（M/S/U） | mstatus, mie, mtvec, misa, medeleg... | 权限最高       |
| **S 模式**              | S/U 级 CSR     | sstatus, sie, sepc, satp...           | 中间权限       |
| **U 模式**              | 仅 U 级 CSR     | ustatus, uie, uepc...                 | 最低权限       |
| **mstatus 与 sstatus** | 属于同类状态寄存器     | sstatus 是 mstatus 的子集映射               | ✅ 共用底层物理存储 |

---

# 十三、RISC-V自定义指令

本部分详细讲解 **RISC-V 自定义指令集（Custom Instructions）** 的概念、分类、编码以及应用。

---

## 13.1 什么是 RISC-V 自定义指令集

RISC-V 作为开源指令集，标准指令集本身覆盖了基础整数运算（I）、乘除运算（M）、原子操作（A）、浮点运算（F/D）、矢量指令（V）等。但在实际应用中，硬件设计者可能希望增加**特定功能的专用指令**来提升性能，例如：

* 特定算法加速（加密、压缩、矩阵运算等）
* DSP（数字信号处理）操作
* 自定义硬件接口控制

这类不属于标准指令集的指令，被称为 **自定义指令（Custom Instructions）**。

### 特点：

1. 不破坏原有标准指令集的兼容性。
2. 可以直接映射到硬件单元，减少指令周期。
3. 可用于加速特定算法或功能。

---

## 13.2 自定义指令的分类

RISC-V 自定义指令主要通过保留的 **opcode 空间** 来实现：

| 类型         | opcode 范围 | 说明        |
| ---------- | --------- | --------- |
| `CUSTOM-0` | `0001011` | 用户自定义指令 0 |
| `CUSTOM-1` | `0101011` | 用户自定义指令 1 |
| `CUSTOM-2` | `1011011` | 用户自定义指令 2 |
| `CUSTOM-3` | `1111011` | 用户自定义指令 3 |

> 注：这些 opcode 是 RISC-V 标准预留的，用于自定义扩展。

* **CUSTOM-0** 和 **CUSTOM-1**：通常用于整数和简单操作。
* **CUSTOM-2** 和 **CUSTOM-3**：可以用于更复杂的操作，或者浮点/矢量扩展。

---

## 13.3 自定义指令编码结构

RISC-V 指令的基本格式包括：

| 类型    | 位数   | 字段         | 说明  |         |           |          |         |           |
| ----- | ---- | ---------- | --- | ------- | --------- | -------- | ------- | --------- |
| R 型   | 32 位 | `funct7    | rs2 | rs1     | funct3    | rd       | opcode` | 寄存器到寄存器运算 |
| I 型   | 32 位 | `imm[11:0] | rs1 | funct3  | rd        | opcode`  | 立即数运算   |           |
| S 型   | 32 位 | `imm[11:5] | rs2 | rs1     | funct3    | imm[4:0] | opcode` | 存储指令      |
| U/J 型 | 32 位 | `imm       | rd  | opcode` | 跳转或加载大立即数 |          |         |           |

**自定义指令**通常使用 R 型或 I 型来实现，例如：

```text
R 型自定义指令：
funct7 | rs2 | rs1 | funct3 | rd | opcode=CUSTOM-0
```

* `opcode`：标识自定义指令类别
* `funct3` / `funct7`：用于区分不同的具体操作
* `rd` / `rs1` / `rs2`：操作数寄存器

---

## 13.4 自定义指令的设计方法

1. **确定功能需求**
   例如，你想设计一个 `ADD3` 指令，用于一次性将三个寄存器的值相加：

   ```text
   ADD3 rd, rs1, rs2, rs3
   ```

   * 这在标准 RISC-V 中需要两条指令完成。

2. **选择 opcode**
   假设使用 `CUSTOM-0`。

3. **定义 funct7 / funct3**

   * `funct7=0000001` → 标识 ADD3
   * `funct3=000` → 保留

4. **映射硬件执行单元**

   * 在 CPU 的 ALU 中增加对应逻辑。
   * 指令译码时根据 opcode + funct7 确定操作。

---

## 13.5 自定义指令示例

**示例 1：三寄存器加法（R 型）**

```assembly
ADD3 x5, x6, x7, x8  # x5 = x6 + x7 + x8
```

对应自定义指令编码：

```
funct7=0000001 | rs2=x7 | rs1=x6 | funct3=000 | rd=x5 | opcode=CUSTOM-0
```

**示例 2：位域操作（I 型立即数）**

```assembly
BSETI x5, x6, 3  # 将 x6 的第3位置1，结果写入 x5
```

* `opcode=CUSTOM-1`
* `imm=3`
* `rs1=x6`
* `rd=x5`
* `funct3/7` 自定义区分不同位操作

---

## 13.6 使用自定义指令的注意事项

1. **兼容性问题**：

   * 自定义指令无法在其他不支持扩展的 RISC-V CPU 上运行。
2. **硬件复杂度**：

   * 增加自定义指令会增加 ALU 或特殊功能单元设计复杂度。
3. **软件支持**：

   * 编译器需要通过 **内嵌汇编（inline assembly）** 或 **GCC/LLVM 插件** 支持自定义指令。
4. **调试**：

   * 模拟器需更新 ISA 描述，否则无法识别自定义指令。

---

## 13.7 总结

* **RISC-V 自定义指令**提供了灵活扩展的能力，用于特定应用的性能优化。
* 通过保留的 **CUSTOM-0/1/2/3 opcode** 可以设计自己的 R/I 型指令。
* 设计步骤：功能定义 → 选择 opcode → 定义 funct3/funct7 → 映射硬件 → 更新编译器/工具链。
* 常见应用：加速算法、位操作、DSP 运算、加密、压缩等。

---


